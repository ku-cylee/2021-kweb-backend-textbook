\section{Authentication Routes Implementation}\label{sect:auth-routes-implementation}

\subsection*{Routing}

이번 장에서는 사용자 인증 기능을 담당하는 라우팅을 설계하고 구현해본다. 먼저, 웹 사이트의 홈 페이지 라우트는 다음과 같이 정할 수 있다.

\begin{itemize}
    \item GET /: 홈 페이지
\end{itemize}

인증과 기능은 크게 회원 가입(sign up), 로그인(sign in), 로그아웃(sign out) 등이 있다. \sectref{sect:express-js-and-view-engine-exercises}의 \excref{exc:form-login}에서 이미 GET 메서드를 통해 로그인 페이지를 응답받고, POST 메서드를 통해 로그인 데이터를 받은 바 있다. 따라서 다음과 같이 라우트를 설계할 수 있다.

\begin{itemize}
    \item GET /auth/sign\_in : 로그인 페이지
    \item POST /auth/sign\_in : 로그인 데이터를 받아서 인증
    \item GET /auth/sign\_up : 회원가입 페이지
    \item POST /auth/sign\_up : 회원가입 데이터를 받아서 인증
    \item GET /auth/sign\_out : 로그아웃 처리\footnote{로그아웃 기능은 POST 메서드로 처리하는 것이 좋으나, 본 교재에서는 일단 GET 메서드로 처리한다.}
\end{itemize}

\subsection*{Controller Implementation}

각 라우트에 대한 컨트롤러를 구현해보자. 모든 컨트롤러는 \coderef{code:controller-format}\와 같은 형태를 가지며, 컨트롤러에서 에러가 발생하면 \cd{next} 함수에 에러 객체 \cd{err}를 전달하여 호출한다.

\begin{codeenv}{code:controller-format}{Controller Format}\begin{verbatim}
const controllerName = async (req, res, next) => {
    try {
        // Controller function
    } catch (err) {
        return next(err);
    }
};
\end{verbatim}
\end{codeenv}

src/controller/ctrl.js를 생성하고, 다음 controller를 구현한 뒤 export하여라. 구현 결과는 \coderef{code:index-ctrl}\를 참고하여라.

\subsubsection*{\cd{indexPage}}
\begin{itemize}
    \item GET / → 웹 사이트의 홈페이지를 응답
    \item 템플릿: views/index.pug
    \begin{itemize}
        \item \cd{user}: 현재 로그인된 사용자 객체
    \end{itemize}
    \item Hint
    \begin{itemize}
        \item 템플릿 파일의 렌더링: \sectref{sect:view-engine} 참고
        \item 사용자 정보는 세션 객체의 user 객체에 저장된다. (\sectref{sect:http-cookie-and-session})
    \end{itemize}
\end{itemize}

src/controller/auth/ctrl.js를 생성하고, 다음 controller를 구현한 뒤 export하여라. 필요에 따라 적절한 모듈을 import하여 사용하여라. 구현 결과는 \coderef{code:auth-ctrl}\를 참고하여라.

\subsubsection*{\cd{signInForm}}
\begin{itemize}
    \item GET /auth/sign\_in
    \begin{itemize}
        \item 로그인된 사용자 → 홈으로 redirect
        \item 로그인되지 않은 사용자 → 로그인 페이지 응답
    \end{itemize}
    \item 템플릿: views/auth/sign-in.pug
    \begin{itemize}
        \item \cd{user}: 현재 로그인된 사용자 객체
    \end{itemize}
    \item Hint: 로그인되지 않은 사용자의 \cd{user} 값은 \cd{undefined}이다.
\end{itemize}

\subsubsection*{\cd{signIn}}
\begin{itemize}
    \item POST /auth/sign\_in → HTTP 요청의 body의 아이디와 비밀번호를 받아 로그인 처리
    \begin{itemize}
        \item 아이디(username)나 비밀번호(password)가 없다면 \cd{BAD\_REQUEST} 에러 발생
        \item DB에서 \cd{username}이 일치하는 사용자가 없으면 \cd{UNAUTHORIZED} 에러 발생
        \item 요청받은 비밀번호와 사용자의 비밀번호가 불일치하면 \cd{UNAUTHORIZED} 에러 발생
        \item 사용자의 \cd{id}, 아이디(\cd{username}), 닉네임(\cd{displayName}), 탈퇴 여부(\cd{isActive}), 관리자 여부(\cd{isStaff}) 정보를 담은 객체를 생성하여 세션의 \cd{user} 객체로 등록
        \item 홈으로 redirect
    \end{itemize}
    \item Hint
    \begin{itemize}
        \item \cd{ERROR\_NAME} 에러를 발생시키는 방법: \cd{throw new Error('ERROR\_NAME')}
        \item 세션을 생성하는 방법: \sectref{sect:http-cookie-and-session} 참고
    \end{itemize}
\end{itemize}

\subsubsection*{\cd{signUpForm}}
\begin{itemize}
    \item GET /auth/sign\_up → 회원가입 페이지 응답
    \item 템플릿: views/auth/sign-up.pug
    \begin{itemize}
        \item \cd{user}: 현재 로그인된 사용자 객체
    \end{itemize}
\end{itemize}

\subsubsection*{\cd{signUp}}
\begin{itemize}
    \item POST /auth/sign\_up → HTTP 요청의 body의 아이디와 비밀번호, 닉네임을 받아 회원가입 처리
    \begin{itemize}
        \item 아이디(\cd{username}), 비밀번호(\cd{password}), 닉네임(\cd{displayName})이 없거나 저장 가능한 최대 길이를 초과하면 \cd{BAD\_REQUEST} 에러 발생
        \item 사용자가 입력한 비밀번호를 이용하여 암호화된 비밀번호 생성
        \item DB에 새로운 사용자 데이터 생성
        \item 로그인 페이지로 redirect
    \end{itemize}
    \item Hint: 저장 가능한 최대 길이는 해당 column의 자료형을 확인
\end{itemize}

\subsubsection*{\cd{signOut}}
\begin{itemize}
    \item GET /auth/sign\_out → 로그아웃 처리, 완료 시 홈으로 redirect
    \item Hint: 세션을 삭제하는 방법은 \sectref{sect:http-cookie-and-session} 참고
\end{itemize}

\begin{codeenv}{code:auth-routing}{Auth Routing}\begin{verbatim}
const { Router } = require('express');

const ctrl = require('./ctrl');

const router = Router();

router.get('/sign_in', ctrl.signInForm);
router.post('/sign_in', ctrl.signIn);

router.get('/sign_up', ctrl.signUpForm);
router.post('/sign_up', ctrl.signUp);

router.get('/sign_out', ctrl.signOut);

module.exports = router;
\end{verbatim}
\end{codeenv}

이제 각 controller 함수를 각 라우트에 연결하는 라우팅을 해보자. 먼저 src/controller/auth/index.js를 생성하고, \coderef{code:auth-routing}\과 같이 작성한다. \coderef{code:auth-routing}에는 express의 \cd{Router} 객체를 이용하여 경로가 /auth로 시작하는 라우트만 라우팅하며, 각 라우트의 경로에서 /auth는 생략한다. 그리고 이 \cd{Router} 객체를 export한다.

\begin{codeenv}{code:index-routing}{Index Routing}\begin{verbatim}
const { Router } = require('express');

const ctrl = require('./ctrl');
const auth = require('./auth');

const router = Router();

router.get('/', ctrl.indexPage);

router.use('/auth', auth);

module.exports = router;
\end{verbatim}
\end{codeenv}

src/controller/index.js를 생성하고, \coderef{code:index-routing}\과 같이 작성한다. \coderef{code:index-routing}에서는 express의 \cd{Router} 객체에 GET / 라우트의 controller 함수를 등록하였고, \coderef{code:auth-routing}에서 작성한 \cd{Router} 객체를 /auth로 시작하는 경로에 대해서만 실행되는 미들웨어로 bind하였다. 이러한 구조는 인증(auth)과 관련된 라우트를 따로 분리하여 작성할 수 있도록 해준다.
\newpage

\begin{codeenv}{code:bind-controller}{Bind Controller Module on \cd{app}}\begin{verbatim}
// omit

const controller = require('./controller');
const { errorHandler } = require('./lib/error-handler');

// omit

app.use('/', controller);

app.use(errorHandler);

module.exports = app;
\end{verbatim}
\end{codeenv}

src/app.js를 \coderef{code:bind-controller}\와 같이 수정하여 /로 시작하는 경로에 대해 src/controller 모듈이 실행될 수 있도록 한다. 이제 \shellref{shell:npm-run-script}\와 같이 서버를 실행하고, 이번 장에서 작성한 기능들을 직접 테스트 해보자.
