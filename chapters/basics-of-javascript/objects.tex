\section{Objects} \label{sect:objects}

\sectref{sect:data-types}에서 객체에 대해 다룬 바 있는데, 이번 절에서는 객체에 대해 더 자세히 알아보자. 객체라는 개념을 정확히 이해하기 위해서는 객체 지향형 프로그래밍(Object-Oriented Programming)을 공부해야 하지만, 본 교재에서 다루는 내용과는 다소 거리가 있으므로 기본적인 내용만 다룬다.

이번 절에서는 클래스와 메서드와 관련된 기초 개념을 다루고, JS에서 기본적으로 제공되는 객체(built-in objects)의 종류와 사용 방법에 대해 학습한다.

\subsection*{Property와 Method}

\coderef{code:object-type}(\pageref{code:object-type}쪽)에서 \texttt{person}이라는 객체에 \texttt{age}, \texttt{name}, \texttt{height}, \texttt{isMale}의 네 속성과 그 값을 부여하였다. 이때 \texttt{person} 객체의 속성의 값을 이용하여 수행하는 작업을 생각해보자. 예를 들어 새해가 되어 \texttt{age} 값을 증가시켜주는 작업은 \texttt{age}의 값을 \texttt{1}만큼 증가시키는 작업이다. 이 작업은 매우 간단하지만, 복잡하고 긴 과정을 거쳐야 하는 작업일 수도 있으므로 \texttt{increaseAge}라는 함수를 만들어두고 사용하는 것이 훨씬 효율적일 것이다.

그런데 JS 파일에 함수를 만들어두고 사용하면 어떤 부작용이 있겠는가? 객체가 많은 프로그램의 경우는 함수의 수가 지나치게 많아져 가독성이 저하되고, 개발자가 헷갈리기 쉬워지고 코드 분석도 어려워지는 등 효율성이 저하될 수 있다. 또한, 다른 객체에 대해 유사한 작업을 수행하는 함수가 있다면 함수 이름이 겹쳐 namespace 오염이 일어날 수 있고, 함수 이름을 비효율적으로 짓게 된다. 따라서 객체의 속성값을 이용하는 함수는 객체 내부에 정의하여 namespace 오염과 부작용을 방지하고, 이를 메서드(method)라고 한다.

\begin{codeenv}{code:object-method}{Method of Object}\begin{verbatim}


> const person = {
      age: 21,
      name: 'Frank',
      height: 170,
      isMale: true,
      increaseAge: function () { this.age++ },
  };
> person.increaseAge();
> person.age;
22
\end{verbatim}
\end{codeenv}

메서드는 \coderef{code:object-method}과 같이 key에 메서드 이름을 작성하고 value에 메서드가 수행할 작업을 함수의 형태로 할당한다. 앞의 \texttt{increaseAge} 메서드는 자신이 속한 \texttt{person} 객체의 \texttt{age} 값을 \texttt{1}만큼 증가시켜야 하는데, 함수 내에 \texttt{age}가 선언되어 있지 않아 직접 접근할 수 없다. 이때 \texttt{this} 키워드를 사용하면 자기 자신이 속한 객체에 접근할 수 있다.\footnote{\texttt{this}는 자기 자신의 객체 외에도 다른 종류의 객체를 가리킬 수도 있다.} 즉 \texttt{increaseAge} 메서드 내부의 \texttt{this}는 \texttt{person}을 가리키고, \texttt{increaseAge}는 자신의 속성 \texttt{age}의 값을 \texttt{1}만큼 증가시킨다.

\begin{codeenv}{code:object-simple-method}{Simple Method Syntax}\begin{verbatim}


> const person = {
      age: 21,
      increaseAge() { this.age++ },
  };
> person.increaseAge();
> person.age;
22
\end{verbatim}
\end{codeenv}

ES6의 축약 메서드 표현법에 따라 \coderef{code:object-simple-method}과 같이 축약하여 표현할 수 있다.

메서드를 표현할 때 arrow function을 이용하면 오류가 발생할 여지가 크다는 점을 주의해야 한다. 화살표 함수는 \texttt{this}가 가리키는 객체를 정하는 방식이 일반적인 함수와 다르므로\footnote{https://poiemaweb.com/es6-arrow-function} 메서드를 표현할 때는 arrow function보다는 일반적인 함수 표현 방식을 사용하는 것이 좋다.

\subsection*{Class and Instance}

앞에서는 Frank라는 이름을 가진 사람에 대한 정보를 다루기 위해 \texttt{person}이라는 객체를 생성하고 속성과 메서드를 정의하였다. 그런데 Frank라는 사람 한 명뿐만 아니라 같은 속성을 갖는 수많은 사람에 대한 정보를 다루려고 할 때 \coderef{code:object-method}과 같이 객체를 일일이 생성하는 방식은 매우 비효율적이며 재사용성이 크게 떨어진다.

이렇게 동일한 형태의 객체들을 생성하기 위해 클래스(class)를 이용하여 객체들의 구조를 표현하며, 클래스는 설계도와 같은 역할을 한다. 클래스는 각 객체가 갖는 속성, 상수, 메서드 등에 대한 정보의 집합이다. 그리고 이러한 설계도, 즉 클래스에 따라 생성된 각 객체를 인스턴스(instance)라고 한다. 예를 들어 \texttt{Person}이라는 클래스가 있다면 이 클래스에 따라 생성된 객체 \texttt{frank}, \texttt{david}, \texttt{jennie} 등은 인스턴스이다.

인스턴스를 생성하려면 클래스라는 설계도를 이용하여 객체를 생성하는 매개체가 필요하다. 이 매개체를 생성자(constructor)라고 부르며, 생성자는 인스턴스를 생성할 때 필요한 정보를 받아, 설계도에 따라 객체의 속성이나 메서드를 정한다. 예를 들어, 앞의 \texttt{Person} 클래스의 생성자는 나이, 이름, 키, 성별 등의 정보를 받아 \texttt{age}, \texttt{name}, \texttt{height}, \texttt{isMale}의 속성값에 저장할 것이다. 또한, 생성자는 여러 유의미한 정보가 응집되어 있는 정보를 나누어 서로 다른 속성에 저장하기도 한다. 예를 들어, 학생의 학번을 받아서 입학 연도, 소속 학과, 개인 일련번호 등의 정보를 저장하는 \texttt{Student}라는 클래스를 가정한다면 이 클래스의 생성자는 학번을 분석하여 \texttt{admissionYear}, \texttt{department}, \texttt{serialNumber} 등의 속성에 분석한 값들을 저장할 수 있다.

속성이나 메서드는 자신이 속한 클래스와 연관성은 크지만, 생성자가 필요하지 않을 수도 있다. 이러한 메서드를 정적(static) 속성 및 정적 메서드라고 하며, 생성자를 사용하지 않고 클래스에서 직접 속성이나 메서드를 호출할 수 있다.
