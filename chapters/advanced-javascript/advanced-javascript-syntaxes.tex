\section{Advanced Javascript Syntaxes}\label{sect:advanced-javascript-syntaxes}

\subsection*{Template Literal}

문자열을 생성할 때 문자열 내에 변수값을 삽입하여 특정 부분의 값이 변수의 값에 따라 바뀌도록 생성하는 경우가 많다. 지금까지는 이러한 변수들을 문자열 연결(concatenation)을 통해 연결하여 문자열을 생성하곤 했다. 예를 들어 \coderef{code:string-format-without-template-literal}\은 \cd{x}, \cd{y} 두 인자를 받아 \cd{x}의 \cd{y} 제곱의 값을 출력하는 함수가 구현된 코드이다.

\begin{codeenv}{code:string-format-without-template-literal}{String Formatting without Template Literal}\begin{verbatim}
const printPower = (x, y) => {
    const msg = 'Value of ' + x + ' to the power ' + y + ' is ' + x ** y + '.';
    console.log(msg);
};

printPower(3, 4);
\end{verbatim}
\end{codeenv}

\coderef{code:string-format-without-template-literal}\은 의도한 기능은 잘 수행하지만, 두 가지 부수적인 문제점을 갖는다. 먼저 \cd{msg} 문자열에서 변하지 않는 부분과 변하는 부분이 분리되어 있어, 실제 문자열의 형태가 직관적으로 표현되어 있지 않다. 또한, 문자열을 감싸는 문자(\cd{'}), 덧셈 기호(\cd{+}) 등으로 인해 코드가 불필요하게 길어져 가독성을 저해시킨다. 이러한 문제점을 해결하여 문자열 생성을 더 쉽게 할 수 있도록 ES6 이후의 JS에서는 template literal이라는 문법을 제공한다.

Template literal을 이용하여 문자열을 생성하기 위해서는 먼저 일반적인 문자열과는 달리 문자열을 backtick(\cd{`}) 문자로 감싸야 한다. Backtick으로 감싸진 문자열 내에서는 \cd{\$\{}과 \cd{\}}로 감싸진 부분이 JS 표현식으로 인식되어 문자열이 생성될 때 표현식을 나타내는 부분이 감싸진 부분의 표현식의 반환값으로 대체된다.

\coderef{code:string-format-with-template-literal}\은 \coderef{code:string-format-without-template-literal}의 함수를 template literal을 이용하여 표현한 코드이다. 코드가 기존에 비해 매우 직관적이고 깔끔해진 것을 확인할 수 있다.

\begin{codeenv}{code:string-format-with-template-literal}{String Formatting with Template Literal}\begin{verbatim}
const printPower = (x, y) => {
    const msg = `Value of ${x} to the power ${y} is ${x ** y}.`;
    console.log(msg);
};

printPower(3, 4);
\end{verbatim}
\end{codeenv}

여담으로, \cd{\$\{\}} 부분을 표현식이 아닌 일반 문자열로 사용하고 싶은 경우 역슬래시(\cd\textbackslash)를 이용하여 escape 해주면 된다.

\subsection*{Destructuring Assignment}

Destructuring Assignment(비구조화 할당)는 배열의 각 요소나 객체의 각 값을 서로 다른 변수에 저장하는 작업을 편리하게 할 수 있게 하는 문법이다.

\begin{codeenv}{code:array-destructuring}{Array Destructuring}\begin{verbatim}
const arr = [1, 2, 3, 4];

const [a1, a2, a3, a4] = arr;
const [b1, , b3] = arr;
const [, , , c4, c5, c6 = 10] = arr;
\end{verbatim}
\end{codeenv}

\coderef{code:array-destructuring}\은 배열의 비구조화를 나타낸 예제이다. 구문에 대한 간단한 설명은 다음과 같다.

\begin{itemize}
    \item 대입 연산자(\cd{=})의 좌변에 배열의 각 요소의 값이 할당될 변수를 배열 형태로 나타내고, 우변에는 분해하고자 하는 배열을 나타낸다.
    \item 좌변에서 \cd{n}번째에 배치된 요소에는 우변에서 \cd{n}번째에 배치된 요소의 값이 할당된다.
    \item 우변의 일부 값은 좌변에서 생략함으로써 무시할 수 있다.
    \item 좌변의 변수 중 우변에 대응되는 값이 없는 경우 \cd{undefined}가 할당된다.
    \item 좌변에서 특정 변수의 기본값을 설정해주면, 비구조화의 결과로 해당 변수의 값이 \cd{undefined}일 때, 그 변수에는 설정한 기본값이 할당된다.
\end{itemize}

\begin{codeenv}{code:object-destructuring}{Object Destructuring}\begin{verbatim}
const obj = { x: 1, y: 2, z: 3 };
const { x, z, u, v = 10 } = obj;
const { y: y1 } = obj;
\end{verbatim}
\end{codeenv}

\coderef{code:object-destructuring}\은 객체의 비구조화을 나타낸 예제이다. 배열의 비구조화와 전체적으로 유사하며, 차이점은 다음과 같다.

\begin{itemize}
    \item 배열의 비구조화는 위치(index)를 기준으로 match하는 반면, 객체의 비구조화는 속성(property) 이름을 기준으로 match한다.
    \item 객체의 원래 속성 이름과는 다른 이름의 변수에 값을 할당할 수 있다.
\end{itemize}

객체의 비구조화는 객체의 원래 속성의 이름을 변수로써 사용할 때에는 권장되는 문법이다. 예를 들어 \coderef{code:object-destructuring}에서 \cd{obj} 객체의 \cd{x} 속성을 \cd{x}라는 상수에 할당할 때, \cd{const x = obj.x} 같은 표현보다는 \cd{const \{ x \} = obj} 같은 표현이 권장된다.
\newpage

\subsection*{Truthy and Falsy}

JS의 모든 값은 암묵적으로(implicitly) \cd{true}나 \cd{false}로 변환될 수 있다. 암묵적으로 \cd{true}으로 변환되는 값들을 truthy, \cd{false}로 변환되는 값들을 falsy라고 하고, 이러한 암묵적인 변환은 조건문 등에서 조건의 참/거짓을 확인할 때 유용하게 사용된다.

다음 7가지 값은 falsy이며, 나머지 값들은 모두 truthy이다.

\begin{itemize}
    \item \cd{false} / \cd{0} / \cd{-0} / \cd{null} / \cd{undefined} / \cd{""} / \cd{NaN}
\end{itemize}

Truthy, falsy 표현식은 \coderef{code:truthy-and-falsy}\와 같이 사용될 수 있다.

\begin{codeenv}{code:truthy-and-falsy}{Truthy and Falsy Expressions}\begin{verbatim}
if (arr.length > 0) { ... }
// can be converted to
if (arr.length) { ... }

if (foo === undefined) { ... }
// can be converted to
if (!foo) { ... }
\end{verbatim}
\end{codeenv}

\coderef{code:convert-truthy-falsy}\는 truthy/falsy한 값을 \cd{true}/\cd{false}로 변환하는 코드이다.

\begin{codeenv}{code:convert-truthy-falsy}{Converting Truthy and Falsy Values}\begin{verbatim}
const emptyArray = [];
const val1 = !!val1            // true
const val2 = !!val1.length;    // false
\end{verbatim}
\end{codeenv}

JS에서 논리적 OR을 계산하는 방식과, truthy/falsy를 이용하여 short-circuit evaluation(단축 평가)을 실시할 수 있다. 논리적 OR를 계산하는 이항 연산자 \cd{||}는 연산자 앞에 오는 피연산자가 truthy하면 앞에 오는 항을 반환하고, falsy하면 뒤에 오는 피연산자를 반환한다.

\begin{codeenv}{code:short-circuit-eval}{Short Circuit Evaluation}\begin{verbatim}
const port = config.port || 3000;
\end{verbatim}
\end{codeenv}

Short-circuit evaluation은 \coderef{code:short-circuit-eval}\과 같이 변수의 기본값을 설정할 때 유용하게 사용된다. \cd{config.port}의 값이 truthy하면 \cd{port}의 값은 \cd{config.port}의 값이 되고, falsy하면 \cd{3000}이라는 기본값을 갖는다.
\newpage

\subsection*{Error Handling}

프로그램에서 에러가 발생했을 때 이를 적절히 처리하는 작업은 매우 중요하다. 코드에서 에러가 발생하면 그 이후의 코드는 더 이상 실행되지 않기 때문에, 에러가 제대로 처리되지 않은 경우 프로그램 자체가 종료되어 버릴 수 있다. 특히 간단한 프로그램이 아닌 실제 서비스에서 에러가 발생하여 프로그램이 종료되어 버리는 경우 심각한 문제가 발생할 수 있다. 이러한 문제를 방지하기 위해 에러 처리는 적절히 이루어져야 하고, JS에서는 에러 처리를 위한 문법을 제공한다.

\begin{codeenv}{code:function-without-error-handling}{Function Without Error Handling}\begin{verbatim}
const getStatusCode = res => res.status.code;

const code1 = getStatusCode({ status: { code: 400 } });
const code2 = getStatusCode({});
\end{verbatim}
\end{codeenv}

\coderef{code:function-without-error-handling}에서 \cd{getStatusCode} 함수에 의도한 형태의 인자가 들어간다면 에러가 발생하지 않고 값을 정상적으로 반환하지만, 빈 객체와 같이 의도하지 않은 형태의 인자가 들어가면 에러가 발생한다. 이렇게 함수에 의도한 형태의 인자가 들어간다는 보장이 없다면 에러가 발생할 수 있고, 이렇게 발생하는 에러가 적절히 처리되지 않았기 때문에 이 프로그램은 종료되어 버린다.

이러한 에러 처리를 위해서 JS에서는 try-catch 문을 지원한다. try-catch 문은 \cd{try}, \cd{catch}, \cd{finally}로 이루어져 있고, \cd{try} block에서 에러가 발생하면 \cd{catch} block의 코드가 실행되고, 그 다음 에러 발생 여부와 무관하게 \cd{finally} block의 코드가 실행된다. \cd{try} block은 반드시 필요하고, \cd{catch} block이나 \cd{finally} block 중 적어도 하나는 반드시 있어야 한다. 또한, \cd{catch} 문은 발생한 에러와 관련된 속성과 값이 포함되어 있는 에러 객체를 개발자의 필요에 따라 인자로 받을 수 있다.

\coderef{code:function-without-error-handling}\은 try-catch 문을 이용하여 에러 처리를 한 코드이다.

\begin{codeenv}{code:function-with-error-handling}{Function With Error Handling}\begin{verbatim}
const getStatusCode = res => {
    try {
        return res.status.code;
    } catch (err) {
        return 0;
    } finally {
        console.log('getStatusCode called');
    }
};

const code1 = getStatusCode({ status: { code: 400 } });
const code2 = getStatusCode({});
\end{verbatim}
\end{codeenv}

JS에서 기본적으로 제공되는 에러 이외에도, 새로운 에러 클래스(\cd{Error})를 이용하여 에러 객체를 생성하고, \cd{throw} 키워드를 이용하여 개발자의 필요에 따라 에러를 발생시킬 수 있다.

에러 처리를 이용하여 코드의 흐름을 조절할 수 있다. A 함수에서 B 함수를 호출했을 때, B 함수에서 예외 상황이 발생하였다고 가정하자. 개발자는 B 함수에서 발생한 예외 상황를 즉시 처리하지 않고, A 함수에서 처리하기를 희망할 수 있다. 에러 처리가 되어있지 않은 함수는 에러 발생 즉시 종료되므로, B 함수에서 예외 상황과 관련된 에러를 발생시키고, A 함수에서 에러를 처리할 수 있다.

\begin{codeenv}{code:flow-control-with-error-handling}{Controlling Flow with Error Handling}\begin{verbatim}
const validateData = data => {
    if (!data) throw new Error(500);
    if (!data.length) throw new Error(404);
    return data;
};

const createMessage = data => {
    try {
        const checkedData = validateData(data);
        return `Success: ${data}`;
    } catch (e) {
        return `Failed: ${e.message}`;
    }
};

console.log(createMessage());
console.log(createMessage([]));
console.log(createMessage([1, 2, 3]));
\end{verbatim}
\end{codeenv}

\coderef{code:flow-control-with-error-handling}\은 try-catch 문을 이용하여 코드 흐름을 조절한 예제이다. \cd{validateData} 함수에서 데이터를 검증할 때 인자의 형태에 따라 예외적인 경우 그에 맞는 에러를 발생시키면서 예외 처리를 즉시 수행하지 않는다. \cd{createMessage}에서는 \cd{validateData}에서 에러가 발생한다면 \cd{catch} 문으로 코드 흐름이 넘어가고, 그렇지 않는다면 \cd{try} 문의 코드가 실행된다. 이처럼 try-catch 문을 이용하면 예외 처리를 편리하고 깔끔하게 할 수 있고, 코드가 복잡해지고 함수 호출의 단계가 깊어질수록 try-catch 문을 이용하여 코드 흐름을 편리하게 조절할 수 있다.
