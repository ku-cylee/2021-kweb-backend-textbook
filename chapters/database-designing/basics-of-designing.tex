\section{Basics of Designing}\label{sect:basics-of-designing}

\subsection*{자료형 (Data Types)}

Java나 Python 등으로 작성된 프로그램에서 모든 변수가 자료형을 갖듯, 데이터베이스에서 테이블의 각 column은 자료형(data type)을 가지며, 개발자는 각 column에 대해 적절한 자료형을 부여해야 합니다.\footnote{자료형과 무관하게 column의 값이 \cd{NULL}이 될 수 있습니다. 그러나 \cd{NULL} 값의 사용은 지양해야 합니다.}

\begin{tblenv}
    {tab:mariadb-data-types}
    {Data Types of MariaDB (MySQL)}
    {>{\coll}m{0.15\tw}>{\coll}m{0.6\tw}}
    \thickhline
    데이터 타입 & 데이터 유형\tabularnewline
    \hline
    문자형 & \cd{CHAR} ($n<2^8$) / \cd{VARCHAR} ($n<2^{16}$) / \cd{TINYTEXT} ($n<2^8$)
        \\\cd{TEXT} ($n<2^{16}$) / \cd{MEDIUMTEXT} ($n<2^{24}$) / \cd{LONGTEXT} ($n<2^{32}$)\tabularnewline
    숫자형 & \cd{TINYINT} ($n<2^8$) / \cd{SMALLINT} ($n<2^{16}$) / \cd{MEDIUMINT} ($n<2^{24}$)
        \\\cd{INT} ($n<2^{32}$) / \cd{BIGINT} ($\infty$) / \cd{FLOAT} / \cd{DECIMAL} / \cd{DOUBLE}\tabularnewline
    날짜형 & \cd{DATE} / \cd{TIME} / \cd{DATETIME} / \cd{TIMESTAMP} / \cd{YEAR}\tabularnewline
    이진 데이터 & \cd{BINARY} / \cd{BYTE} / \cd{TINYBLOB} / \cd{BLOB} / \cd{MEDIUMBLOB} / \cd{LONGBLOB}\tabularnewline
    \thickhline
\end{tblenv}

\tblref{tab:mariadb-data-types}\는 MariaDB(MySQL)에서 사용할 수 있는 자료형을 나타낸 표입니다. 굵은 글씨체로 표시된 자료형은 주로 사용되는 자료형이며, \cd{VARCHAR}형의 경우 80자가 기본이지만 문자열의 길이를 명시해주는 것이 권장됩니다. 이진 데이터는 이미지나 영상 등 텍스트(text)로 표현되지 않는 데이터를 저장하기 위한 자료형이지만, 이진 데이터는 데이터베이스에 오버헤드를 초래하여 효율을 떨어뜨리기 때문에 권장되지 않는 자료형입니다. 대신, 이진 데이터를 별도의 파일로 저장하고 해당 파일의 경로를 DB에 저장하는 것이 일반적인 방법입니다.

\subsection*{Designing Simple Table}

지금까지 스터디한 내용을 바탕으로, 간단한 DB 테이블을 설계해봅시다. 배달 주문을 받는 식당에 대한 데이터를 저장하는 데이터베이스를 설계하고자 합니다. 식당에 대한 데이터에는 이름(\cd{name}), 전화번호(\cd{telephone}), 식당 주소(\cd{address}), 최소 주문 가격(\cd{min\_price}), 배달 요금(\cd{delivery\_fee}) 등이 있을 것입니다. 이런 방식으로 식당에 대한 데이터를 정리하면 \tblref{tab:table-example}\과 같은 형태로 나타나게 될 것입니다.

\begin{tblenv}
    {tab:table-example}
    {Example of Table About Fast Food Restaurants}
    {>{\colc}m{0.08\tw}|>{\colc}m{0.15\tw}|>{\colc}m{0.3\tw}|>{\colc}m{0.15\tw}|>{\colc}m{0.15\tw}}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{name} & \cd{telephone} & \cd{address} & \cd{min\_price} & \cd{delivery\_fee}\tabularnewline
    \hline
    롯데리아 & 010-1234-1234 & 서울특별시 성북구 보문동 & 12000 & 0\tabularnewline
    \hline
    KFC & 010-1234-5678 & 서울특별시 성북구 동선동 & 14000 & 0\tabularnewline
    \hline
    버거킹 & 010-5678-1234 & 서울특별시 동대문구 용신동 & 12000 & 1000\tabularnewline
    \hline
    맥도날드 & 010-5678-5678 & 서울특별시 성북구 안암동 & 10000 & 2000\tabularnewline
    \thickhline
\end{tblenv}

\tblref{tab:table-example}의 각 column에 자료형을 부여해봅시다. 먼저 telephone column은 문자형이며, 길이를 13자로 제한하면 데이터를 충분히 저장할 수 있으므로 자료형을 \cd{VARCHAR(13)}으로 정할 수 있습니다. 숫자형 데이터인 \cd{min\_price}와 \cd{delivery\_fee}는 INT형으로 정할 수 있습니다. \cd{name}과 \cd{address}는 문자형 데이터로, 앞으로 추가될 수 있는 데이터를 고려하면 \cd{name}은 32자, \cd{address}는 64자로 제한해도 충분할 것으로 예상이 됩니다. 따라서 \cd{name}과 \cd{address}의 자료형을 각각 \cd{VARCHAR(32)}와 \cd{VARCHAR(64)}으로 정하겠습니다. 이렇게 부여한 자료형을 반영하여 \tblref{tab:table-example-data-types}\와 같이 나타낼 수 있습니다.

\begin{tblenv}
    {tab:table-example-data-types}
    {Example of Table About Fast Food Restaurants with Data Types}
    {>{\colc}m{0.08\tw}|>{\colc}m{0.15\tw}|>{\colc}m{0.3\tw}|>{\colc}m{0.15\tw}|>{\colc}m{0.15\tw}}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{name} & \cd{telephone} & \cd{address} & \cd{min\_price} & \cd{delivery\_fee}\tabularnewline
    \hline
    \rowcolor{tblheadcolor}
    \cd{VC(32)} & \cd{VC(13)} & \cd{VC(64)} & \cd{INT} & \cd{INT}\tabularnewline
    \hline
    롯데리아 & 010-1234-1234 & 서울특별시 성북구 보문동 & 12000 & 0\tabularnewline
    \hline
    KFC & 010-1234-5678 & 서울특별시 성북구 동선동 & 14000 & 0\tabularnewline
    \hline
    버거킹 & 010-5678-1234 & 서울특별시 동대문구 용신동 & 12000 & 1000\tabularnewline
    \hline
    맥도날드 & 010-5678-5678 & 서울특별시 성북구 안암동 & 10000 & 2000\tabularnewline
    \thickhline
\end{tblenv}

\subsection*{Avoiding Redundancy}

\tblref{tab:table-example-data-types}\는 패스트푸드 식당들의 데이터만 저장한 테이블입니다. 이제 데이터베이스에 패스트푸드가 아닌, 일식, 중식, 디저트, 분식에 해당하는 식당을 추가하려면 어떻게 해야 할까요?

가장 쉽게 떠올릴 수 있는 방법은 동일한 구조의 일식당 테이블, 중식당 테이블 등을 만드는 것입니다. 그러나 이 방법은 두 가지 문제를 갖습니다. 먼저 구조가 유사한 테이블을 여러 개 만드는 것은 중복을 초래합니다. 프로그램을 설계할 때도 코드의 중복을 피하고자 함수를 사용하는 것처럼, DB의 설계에서도 중복은 가급적 피해야 합니다. 두 번째 문제점은 DB를 사용하는 애플리케이션이 테이블을 직접 생성해야 한다는 점입니다. 애플리케이션은 DB에 있는 데이터에 대해 CRUD 기능만 수행하도록 설계되어야 하고, 테이블을 추가하거나 column을 추가하는 등의 설계 자체를 바꾸는 기능을 수행해서는 안 됩니다. 위와 같이 분류에 따라 매번 테이블을 만든다면, 애플리케이션에서 새로운 분류의 식당을 추가하려고 할 때마다 DB 관리자에게 새로운 테이블을 생성할 것을 요청하여 추가하여야 합니다.

이렇듯 각 식당에 대한 데이터를 분류에 따라 저장할 때 분류마다 테이블을 추가하는 것은 매우 비효율적인 방법이므로, 다른 대안이 필요합니다. 가장 이상적인 방법은 모든 식당의 데이터를 모두 한 테이블에 저장하고, 일식/중식/분식/패스트푸드 등의 정보를 저장하는 category column을 생성하는 것입니다. \tblref{tab:table-example-categories}\는 \tblref{tab:table-example-data-types}에 category column을 새로 생성한 테이블입니다. 이처럼 테이블을 설계하면 앞에서 제시된 문제점들이 해결되며, 저장된 데이터를 조회할 때 분류에 따라 데이터를 조회하기도 간편합니다.

\begin{tblenv}
    {tab:table-example-categories}
    {Example of Table About Fast Food Restaurants with Categories}
    {>{\colc}m{0.08\tw}|>{\colc}m{0.14\tw}|>{\colc}m{0.25\tw}|>{\colc}m{0.13\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.12\tw}}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{name} & \cd{telephone} & \cd{address} & \cd{category} & \cd{min\_price} & \cd{delivery\_fee}\tabularnewline
    \hline
    \rowcolor{tblheadcolor}
    \cd{VC(32)} & \cd{VC(13)} & \cd{VC(64)} & \cd{VC(8)} & \cd{INT} & \cd{INT}\tabularnewline
    \hline
    롯데리아 & 010-1234-1234 & 서울특별시 성북구 보문동 & 패스트푸드 & 12000 & 0\tabularnewline
    \hline
    KFC & 010-1234-5678 & 서울특별시 성북구 동선동 & 패스트푸드 & 14000 & 0\tabularnewline
    \hline
    버거킹 & 010-5678-1234 & 서울특별시 동대문구 용신동 & 패스트푸드 & 12000 & 1000\tabularnewline
    \hline
    맥도날드 & 010-5678-5678 & 서울특별시 성북구 안암동 & 패스트푸드 & 10000 & 2000\tabularnewline
    \hline
    설빙 & 010-3456-3456 & 서울특별시 성북구 안암동 & 디저트 & 8900 & 2500\tabularnewline
    \hline
    엽떡 & 010-8912-8912 & 서울특별시 동대문구 제기동 & 분식 & 14000 & 1000\tabularnewline
    \thickhline
\end{tblenv}

\tblref{tab:table-example-categories}의 테이블에서 \cd{address} 항목에 주목해봅시다. \cd{address} 항목의 각 데이터는 시/구/동의 형태로 분류됩니다. 이 column이 큰 의미를 갖지 않는다면 그대로 두어도 상관없지만, 예를 들어 이 DB를 사용하는 애플리케이션이 위치에 따라 식당을 분류한다면, 각 식당 소재지의 시, 구, 동은 각각 유의미한 데이터가 됩니다. 이렇게 DB에서 column의 값을 최대한 유의미한 단위로 나누어 저장하면 중복을 최소화할 수 있고, 데이터의 조회를 편리하게 할 수 있습니다.

\tblref{tab:table-example-categories}의 \cd{address} column을 \cd{city}, \cd{district}, \cd{town}의 세 column으로 나눌 수 있습니다. 예를 들어 롯데리아 식당의 \cd{address} 값인 ``서울특별시 성북구 보문동''을 세 column으로 나누면, \cd{city}는 ``서울특별시'', \cd{district}는 ``성북구'', \cd{town}은 ``보문동''으로 나눌 수 있습니다. 더 나아가서, DB에 서울 시내의 식당만 저장한다고 가정하면, \cd{city} column은 삭제할 수 있습니다. 이를 모두 반영하면 \tblref{tab:table-example-subdivisions}\와 같은 구조가 됩니다.

\begin{tblenv}
    {tab:table-example-subdivisions}
    {Example of Table About Fast Food Restaurants with Address Subdivisions}
    {>{\colc}m{0.08\tw}|>{\colc}m{0.14\tw}|>{\colc}m{0.11\tw}|>{\colc}m{0.11\tw}|>{\colc}m{0.13\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.12\tw}}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{name} & \cd{telephone} & \cd{district} & \cd{town} & \cd{category} & \cd{min\_price} & \cd{delivery\_fee}\tabularnewline
    \hline
    \rowcolor{tblheadcolor}
    \cd{VC(32)} & \cd{VC(13)} & \cd{VC(16)} & \cd{VC(16)} & \cd{VC(8)} & \cd{INT} & \cd{INT}\tabularnewline
    \hline
    롯데리아 & 010-1234-1234 & 성북구 & 보문동 & 패스트푸드 & 12000 & 0\tabularnewline
    \hline
    KFC & 010-1234-5678 & 성북구 & 동선동 & 패스트푸드 & 14000 & 0\tabularnewline
    \hline
    버거킹 & 010-5678-1234 & 동대문구 & 용신동 & 패스트푸드 & 12000 & 1000\tabularnewline
    \hline
    맥도날드 & 010-5678-5678 & 성북구 & 안암동 & 패스트푸드 & 10000 & 2000\tabularnewline
    \hline
    설빙 & 010-3456-3456 & 성북구 & 안암동 & 디저트 & 8900 & 2500\tabularnewline
    \hline
    엽떡 & 010-8912-8912 & 동대문구 & 제기동 & 분식 & 14000 & 1000\tabularnewline
    \thickhline
\end{tblenv}

\subsection*{Handle Table With SQL}

앞에서 설계한 식당 테이블(\tblref{tab:table-example-subdivisions})을 DB에 생성해봅니다.

\begin{codeenv}{code:create-table-restaurant}{Create Table restaurant}\begin{verbatim}
CREATE TABLE restaurants (
    name VARCHAR(32) NOT NULL,
    telephone VARCHAR(13) NOT NULL,
    district VARCHAR(16) NOT NULL,
    town VARCHAR(16) NOT NULL,
    category VARCHAR(8) NOT NULL,
    min_price INT NOT NULL,
    delivery_fee INT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
\end{verbatim}
\end{codeenv}

\coderef{code:create-table-restaurant}\는 데이터베이스에 \cd{restaurants} 테이블을 생성하고, 하위 column의 이름과 자료형, 그리고 옵션을 기록하는 SQL문입니다.

\begin{sqlenv}{sql:desc}{Description of Table}\begin{verbatim}
DESC <table-name>;
\end{verbatim}
\end{sqlenv}

\sqlref{sql:desc}\과 같이 \cd{DESC} 키워드를 사용하여 테이블의 설계 정보를 확인할 수 있습니다.

\begin{sqlenv}{sql:truncate-and-drop}{Truncate and Drop Table}\begin{verbatim}
TRUNCATE <table-name>;
DROP TABLE <table-name>;
\end{verbatim}
\end{sqlenv}

\shellref{sql:truncate-and-drop}\과 같이 테이블을 삭제할 수 있습니다. \cd{TRUNCATE} 키워드는 테이블의 구조는 유지한 채 데이터만 삭제한다면, \cd{DROP TABLE} 키워드는 테이블 자체를 삭제한다는 차이점이 있습니다.
