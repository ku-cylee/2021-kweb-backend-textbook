\section{Browser Object Model (BOM)} \label{sect:browser-object-model}

브라우저 객체 모델(Browser Object Model; BOM)은 JS가 웹 브라우저의 정보를 읽고, 제어할 수 있도록 하는 객체 모델입니다. BOM은 DOM과는 달리 표준이 없으나, 현대의 브라우저들은 서로 같은 BOM 속성과 메서드를 가지고 출시되기 때문에, 브라우저별로 BOM을 다루는 코드를 다르게 작성할 필요는 없습니다.

\subsection*{Window 객체}

DOM에서 HTML 구조와 관련된 객체들이 모두 document 객체에 포함되어 있었던 것과 유사하게, BOM에서 브라우저와 관련된 객체들은 모두 \texttt{window} 객체에 포함되어 있습니다. 예를 들어, \texttt{alert} 메서드는 경고 메시지를 인자로 받아 웹 브라우저에 경고창을 띄웁니다.

\begin{codeenv}{code:bom-example}{BOM Example}\begin{verbatim}


> window.alert('This is an alert');
> alert('This is an alert');
\end{verbatim}
\end{codeenv}

\coderef{code:bom-example}에서 보듯 \texttt{window} 객체의 속성이나 메서드는 \texttt{window} 객체를 굳이 쓰지 않더라도 사용할 수 있게 되어있습니다. \texttt{document} 객체가 \texttt{window}에 포함된 객체이지만 \sectref{sect:document-object-model}에서 DOM을 다룰 때 \texttt{window.document}로 작성하지 않고 \texttt{document}라고만 작성하여 사용할 수 있었던 이유도 이 때문입니다.

\subsection*{Window 객체의 메서드}

\texttt{window} 객체에서 유용하게 사용되는 메서드는 다음 세 가지가 있습니다.

\begin{itemize}
    \item \texttt{alert}: 문자열을 인자로 받아, 문자열을 경고 메시지로 하는 경고창을 띄웁니다.
    \item \texttt{open}: 새로운 인터넷 창을 엽니다.
    \item \texttt{close}: 현재 창을 닫습니다.
\end{itemize}

\begin{codeenv}{code:}{}\begin{verbatim}


> window.open('https://www.google.com', 'Window Name', 'width=500, height=400');
> window.close();
\end{verbatim}
\end{codeenv}

\subsection*{Screen 객체}

\texttt{window.screen} 객체는 웹 브라우저가 현재 위치한 화면의 크기에 관한 객체입니다.

\begin{itemize}
    \item \texttt{width}, \texttt{height}: 화면의 너비, 높이를 나타냅니다.
    \item \texttt{availWidth}, \texttt{availHeight}: 화면에서 작업 표시줄 등을 제외하고 사용할 수 있는 영역의 너비, 높이를 나타냅니다.
    \item \texttt{colorDepth}: 화면이 나타낼 수 있는 색상의 수를 bit 단위로 나타냅니다. 예를 들어, 24 bits로 표현 가능한 색상의 수는 $2^{24} \approx 1.68 \times 10^7$가지입니다.
\end{itemize}

\subsection*{Location 객체}

\texttt{window.location} 객체는 현재 웹 페이지의 주소에 대해 다루는 객체입니다. 여기에서 이야기하는 \texttt{hostname}, \texttt{pathname}, 프로토콜 등은 back-end 스터디의 HTTP 부분에서 다룹니다.

\begin{itemize}
    \item \texttt{href}: 현재 페이지의 주소를 나타냅니다.
    \item \texttt{hostname}: 현재 페이지 호스트의 도메인 이름을 나타냅니다.
    \item \texttt{pathname}: 현재 페이지의 경로를 나타냅니다.
    \item \texttt{protocol}: 현재 페이지의 프로토콜(HTTP, HTTPS 등)을 나타냅니다.
    \item \texttt{port}: 현재 페이지의 포트를 나타냅니다.
    \item \texttt{assign}: 인자로 받은 문자열을 주소로 하는 웹 문서를 새로 여는 메서드입니다.
\end{itemize}

\subsection*{History 객체}

\texttt{window.history} 객체는 방문한 웹 페이지의 목록을 다루는 객체입니다.

\begin{itemize}
    \item \texttt{back}: 현재 페이지의 이전 페이지를 여는 메서드입니다. 
    \item \texttt{forward}: 현재 페이지 다음 페이지를 여는 메서드입니다. 
    \item \texttt{go}: 방문한 웹 페이지의 목록에서 현재 페이지를 기준으로 인자로 받은 정수만큼 떨어진 페이지를 여는 메서드입니다. 인자가 \texttt{2}이면 두 페이지 앞으로, \texttt{-2}이면 두 페이지 뒤로 이동하며, \texttt{0}인 경우 현재 페이지입니다. 
\end{itemize}

\subsection*{Timeout and Interval}

JS를 이용하여 웹 문서를 동적으로 디자인하다 보면 특정한 시간 간격으로 특정한 작업을 수행해야 하는 경우가 있습니다. 게임에서 공이 포물선 형태로 날아가는 것을 구현하거나, 일정 시간마다 back-end로부터 데이터를 가져와 갱신하는 로직을 구현할 때 특정한 시간 간격으로 작업을 수행해야 합니다. 물론 \texttt{while} 문을 사용하여 구현할 수 있지만, BOM에서는 이러한 로직을 더 쉽게 생성하고, 다룰 수 있는 메서드를 제공합니다.

먼저, \texttt{setTimeout} 메서드는 실행하고자 하는 함수 \texttt{f}와 시간 \texttt{t}를 인자로 받아, 메서드가 호출되고 \texttt{t}ms 후 \texttt{f}를 실행합니다. 또한, 해당 로직을 제어할 수 있는 값인 \texttt{intervalId}를 반환합니다. \texttt{clearTimeout} 메서드는 \texttt{intervalId}를 인자로 받아, 해당 로직을 중단합니다.

\begin{codeenv}{code:timeout-methods}{Timeout Methods}\begin{verbatim}


> const intervalId = setTimeout(() => { console.log('Hello') }, 300);
> clearTimeout(intervalId);
\end{verbatim}
\end{codeenv}

또한, \texttt{setInterval} 메서드는 실행하고자 하는 함수 \texttt{f}와 시간 \texttt{t}를 인자로 받아, 메서드가 호출되고 \texttt{t}ms 간격으로 함수 \texttt{f}를 반복적으로 실행합니다. \texttt{setInterval} 메서드 역시 해당 로직을 제어할 수 있는 값인 \texttt{intervalId}를 반환합니다. \texttt{clearInterval} 메서드는 \texttt{intervalId}를 인자로 받아, 해당 로직을 중단합니다.

\begin{codeenv}{code:interval-methods}{Interval Methods}\begin{verbatim}


> const helloInterval = setInterval(() => {
    console.log('Hello');
}, 400);
> const worldInterval = setInterval(() => {
    console.log('World');
}, 1000);
> clearInterval(helloInterval);
> clearInterval(worldInterval);
\end{verbatim}
\end{codeenv}
