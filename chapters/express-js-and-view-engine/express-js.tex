\section{Express.js}\label{sect:express-js}

\subsection*{Framework}

지금까지 웹 서버를 구현하는데 필요한 기초적인 개념과 스킬을 학습하였고, 유효한 작업을 수행하는 서버를 구현해보았습니다. 앞에서 해본 바와 같이 간단한 기능을 요구하는 서버는 \cd{http} 모듈을 이용하여 구현할 수 있습니다.

그러나 HTTP 요청 경로에 따라 서로 다른 기능을 구현하는 라우팅, query 파싱, 정적 파일 로딩, 에러 처리 등 훨씬 많은 기능을 포함해야 하는 실제 웹 서버는 \cd{http} 모듈을 이용하여 구현하기에는 어려움이 많습니다. 물론 기존의 방식으로 이러한 기능들을 모두 구현하는 것이 불가능한 것은 아니지만, 불필요하며 똑같은 작업을 매번 요구하기 때문에 서버를 구현하는데 굉장한 효율 저하를 초래합니다.

따라서 개발의 효율성을 위해 프레임워크(framework)를 사용하는 경우가 대부분입니다. 프레임워크란, 개발자가 원하는 기능 구현에만 집중할 수 있도록 반복적이며 구현하기 어렵거나 오래 걸리는 로직 등을 미리 갖춰둔 기본 뼈대입니다. 웹 애플리케이션은 기본적이고 공통으로 필요한 기능이 많아서, 많은 프레임워크가 존재합니다. Python은 Django, Flask, Java와 Kotlin은 Spring, PHP는 Laravel이라는 대표적인 웹 프레임워크가 있습니다.

\subsection*{Express.js}

Node.js에서 가장 많이 사용되는 프레임워크에는 Express.js, Koa.js, hapi.js 등이 있습니다. Express.js는 앞의 웹 프레임워크 중 가장 압도적인 점유율을 차지하는 프레임워크이며, Koa.js는 Express.js의 기존 개발팀이 Express.js의 소유권이 이전되면서 장기적인 유지 및 보수가 제대로 이루어지지 않을 것을 우려해 만든 프레임워크입니다.

최근에는 Express.js를 사용한 프로젝트들을 Koa.js로 migration하는 추세이긴 하지만, Express.js의 점유율은 여전히 높으며 그간 Express.js를 많이 사용해왔기 때문에 포럼 등에 Express.js를 다룬 글이 압도적으로 많은 등의 장점이 있습니다. 따라서 준회원 스터디에서는 Express.js 프레임워크를 사용할 것입니다.

\subsection*{간단한 Express 예제}

Express.js 프레임워크를 이용하여 간단한 웹 애플리케이션을 제작해보겠습니다. 먼저 \shellref{shell:create-express-server}\와 같이 Node.js 프로젝트를 생성하고, \cd{express} 모듈을 설치한 뒤, .gitignore 파일을 생성합니다.

\begin{shellenv}{shell:create-express-server}{Create Express Server}\begin{verbatim}
$ npm init -y
$ npm install express
\end{verbatim}
\end{shellenv}

\cd{npm init} 명령을 실행하면 Node.js 프로젝트에 관한 정보를 담은 파일인 package.json이 생성되며, \cd{-y} 옵션을 붙이면 기본 설정을 그대로 사용할 수 있습니다. 또한, 프로젝트에서 사용하는 모듈을 npm을 이용하여 설치하면 모듈들의 이름과 버전이 \cd{dependencies} 속성에 저장되어, 다른 디바이스에서 프로젝트를 실행할 때 모듈 파일들을 직접 복사하지 않고도 모듈을 설치할 수 있습니다.

이제 index.js를 생성하고, \coderef{code:simple-express-server}의 코드를 작성한 후 실행합니다.

\begin{codeenv}{code:simple-express-server}{Simple Express Server}\begin{verbatim}
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => res.send('Hello World!'));

app.listen(port, () => console.log(`Server listening on port ${port}!`));
\end{verbatim}
\end{codeenv}

\coderef{code:simple-express-server}\는 \coderef{code:nodejs-simple-web-server}(\pageref{code:nodejs-simple-web-server}쪽)\를 Express.js를 사용하여 다시 작성한 코드입니다. \coderef{code:nodejs-simple-web-server}\와 거의 같은 기능을 하면서, 코드는 매우 간결해진 것을 확인할 수 있습니다.

먼저 \cd{express} 모듈을 이용하여 \cd{app} 객체를 생성합니다. \cd{app} 객체에는 웹 애플리케이션의 설계에 대한 모든 정보를 담습니다. 이후 서버에 GET /으로 요청이 들어오면, Hello World!라는 문자열을 응답으로 보내는 로직이 구현되어 있습니다.

\subsection*{Routing}

웹 애플리케이션에서 경로(path)는 웹 페이지가 수행하는 작업을 나타내고, 웹 애플리케이션을 작업에 따라 나눈다는 점에서 매우 중요한 의미를 갖습니다. 이렇게 HTTP 요청의 경로와 메서드 등에 따라 서버가 어떻게 HTTP 응답을 반환할지 분배하는 작업을 라우팅(routing)이라고 합니다.

예를 들어, 게시물을 작성하고 열람할 수 있는 웹 앱을 설계한다고 가정했을 때, 개발자는 다음과 같이 라우팅을 할 수 있습니다.

\begin{itemize}
    \item GET /auth/login : 로그인을 할 수 있는 페이지 응답
    \item POST /auth/login : ID와 비밀번호를 받아서 사용자의 인증 요청을 처리하고, 결과를 응답
    \item GET /board/page/1 : 게시판의 첫 번째 페이지 응답
    \item GET /post/3 : 서버에 저장된 게시물 중 3번 게시물을 응답
\end{itemize}

Express.js는 이러한 routing을 손쉽게 할 수 있는 메서드를 제공합니다. Routing에서 사용되는 메서드의 이름은 HTTP 메서드와 일치하고, 인자는 match할 경로와 match 되었을 때 실행될 함수, 즉 controller 함수를 순서대로 받습니다. 이때 match할 경로는 정규 표현식의 형태로 표현할 수 있습니다.

\subsection*{Request and Response Objects}

웹 애플리케이션은 HTTP 요청을 받아 알맞은 작업을 수행한 뒤 HTTP 응답을 반환하는 애플리케이션입니다. \sectref{sect:hypertext-transfer-protocol}에서 다루었듯 HTTP 요청과 응답은 메서드, 경로, 상태 코드 등의 정보 외에도 수많은 정보를 담고 있습니다. 이러한 정보에 따라 수행되는 작업이나 세부적인 값이 조금씩 달라질 수 있으므로, 개발자는 이 정보들을 얻을 수 있어야 합니다.

앞의 Routing 메서드는 controller 함수에 요청 객체와 응답 객체를 인자로 제공합니다. 이는 \coderef{code:simple-express-server}에서도 확인할 수 있습니다. 요청 객체에는 \cd{query}, \cd{body}, \cd{cookie} 등 클라이언트가 전송한 HTTP 요청에 대한 여러 정보가 포함되어 있어, 개발자는 이를 이용하여 요청을 처리할 수 있습니다.

응답 객체를 이용하면 응답의 상태나 내용을 정할 수 있습니다. \cd{send} 메서드를 이용하여 HTTP 응답 메시지를 보낼 수 있고, \cd{redirect} 메서드를 이용하여 다른 페이지로 리다이렉트 시킬 수 있습니다. 또한, \cd{sendStatus} 메서드를 이용하여 상태 코드를 설정하여 응답을 보낼 수 있습니다.

\subsection*{Middleware}

Express.js에서는 요청 객체에 대한 전처리, logging, 에러 처리, 라우팅 등을 middleware(미들웨어)의 형태로 작성할 수 있도록 하고 있습니다. 미들웨어는 요청 객체와 응답 객체, 그리고 요청-응답 과정 중 그 다음 미들웨어 함수에 대한 접근 권한을 갖는 함수입니다.

\begin{codeenv}{code:middleware-example}{Middleware Example}\begin{verbatim}
const express = require('express');
const app = express();
const port = 3000;

app.use((req, res, next) => {
    console.log(`Time: ${new Date().toString()}`);
    next();
});

app.get('/', (req, res) => res.send('GET /'));

app.listen(port, () => console.log(`Server listening on port ${port}!`));
\end{verbatim}
\end{codeenv}

\coderef{code:middleware-example}\을 실행해보면, GET / 요청을 처리하는 컨트롤러 함수에서는 콘솔에 어떠한 문자열도 출력하지 않는데도 불구하고, GET / 요청을 보냈을 때 쉘에 요청을 보낸 시각이 출력되는 것을 확인할 수 있습니다. 이는 바로 미들웨어에서 요청을 받은 시각을 출력하는 작업을 수행했기 때문입니다.

Express 객체의 use 메서드를 사용하여, \cd{app} 객체에서 사용할 미들웨어를 추가할 수 있습니다. 이렇게 \cd{app} 객체에 등록된 미들웨어는 추가된 순서대로 실행됩니다. 또한, 미들웨어는 다음 미들웨어를 실행할 수도, 실행하지 않을 수도 있는데, 미들웨어의 인자로 받은 \cd{next} 함수를 호출하면 다음 미들웨어를 실행합니다. (\figref{fig:middlewares-flow})

\figures{fig:middlewares-flow}{Flow of Code using Middlewares}{
    \fig{images/express-js-and-view-engine/middlewares-flow.png}{.9}
}

Express.js로 생성된 애플리케이션은 간단히 말해서 일련의 미들웨어를 순차적으로 호출하는 애플리케이션입니다. 그러므로 요청 객체와 응답 객체에 접근하여 값을 읽고, 추가하고, 수정할 수 있는 미들웨어는 Express.js 프레임워크에서 매우 강력한 툴입니다.

라우팅 역시 미들웨어로 수행될 수 있습니다. router.js를 생성하고, \coderef{code:middleware-routing-router}\와 같이 작성합니다.

\begin{codeenv}{code:middleware-routing-router}{Routing with Middleware - router.js}\begin{verbatim}
const { Router } = require('express');

const router = Router();

router.get('/', (req, res) => res.send('GET /'));

module.exports = router;
\end{verbatim}
\end{codeenv}

index.js를 \coderef{code:middleware-routing-index}\와 같이 수정합니다.

\begin{codeenv}{code:middleware-routing-index}{Routing with Middleware - index.js}\begin{verbatim}
const express = require('express');
const router = require('./router');
const port = 3000;

const app = express();

app.use('/', router);

app.listen(port, () => console.log(`Server listening on port ${port}!`));
\end{verbatim}
\end{codeenv}

이렇게 작성한 프로그램은 \coderef{code:simple-express-server}\와 동일하게 동작합니다. 그러나 \cd{Router} 객체를 이용하여 라우팅하면 예제와 같이 라우팅과 관련된 코드를 분리하여 모듈화할 수 있다는 장점이 있습니다.

이처럼 미들웨어는 라우팅과 무관하게 모든 요청과 응답에 대해 일괄적으로 코드를 수행할 수 있으므로, 미들웨어는 Express.js에서 매우 강력한 툴입니다. 그렇기 때문에 Express.js에서 사용되기 위해 개발된, logging하는 모듈, HTTP 요청을 가공하는 모듈 등은 모두 미들웨어 형태로 구현되어 있고, 이러한 모듈을 적극적으로 사용하여 애플리케이션 개발 효율을 매우 높일 수 있습니다.

\subsection*{Insomnia}
지금까지는 구현한 서버 애플리케이션을 의도한 바와 같이 작동하는지 확인하기 위해 인터넷 브라우저에 URL을 입력하여 접속하였습니다. 그러나 이러한 방식은, HTTP 요청을 보낼 때 메서드를 특정할 수 없다는 한계점이 있습니다. 더 정확히 말하면, 이와 같은 방식으로는 GET 요청만 보낼 수 있습니다. 이러한 문제점을 해결하기 위해 HTTP 요청을 직접 생성하여 보내 HTTP 응답을 확인할 수 있는 프로그램인 Insomnia를 사용할 것입니다.

\begin{itemize}
    \item 설치: https://insomnia.rest/download/core
\end{itemize}
