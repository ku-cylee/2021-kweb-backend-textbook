\section{View Engine}\label{sect:view-engine}

\subsection*{View Engine의 필요성}

지금까지 Express.js를 이용하여 HTTP 요청을 받고 요청 정보에 따라 적절한 HTTP 응답을 반환하는 웹 애플리케이션을 구현해 보였습니다. 지금까지 구현한 애플리케이션은 HTTP 응답으로 plain text 형태의 응답만을 반환하였는데, 애플리케이션을 Restful하게 구현하지 않는 이상 대부분의 HTTP 응답은 HTML 형태를 갖습니다. 앞에서 구현한 방식 그대로, \coderef{code:express-server-responding-html}\과 같이 HTML 형태의 응답을 반환할 수 있습니다.

\begin{codeenv}{code:express-server-responding-html}{Express Server Responding HTML}\begin{verbatim}
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => res.send(`
    <h1>GET /</h1>
    <h3>Hello World!</h3>
`));

app.listen(port, () => console.log(`Server listening on port ${port}!`));
\end{verbatim}
\end{codeenv}

\coderef{code:express-server-responding-html}처럼 HTML 응답을 반환할 수는 있으나, 이렇게 HTML 문서를 직접 코드에 넣어 응답하는 방식은 문제점이 많습니다. 가장 큰 문제점은 코드의 가독성이 매우 저하된다는 점입니다. 통상적인 웹 페이지의 HTML 코드는 매우 긴데, 이런 경우 로직의 구현에 집중해야 할 코드의 대부분을 HTML 코드가 차지하게 되어 가독성을 심각하게 저하시키고 유지 및 보수를 어렵게 합니다. 또한, 때에 따라 페이지 내부 내용의 값이 바뀐다거나, HTML 문서의 특정 부분이 조건에 따라 바뀌어야 한다거나, 반복되어야 할 때 JS를 이용하여 HTML 문자열을 생성하기에는 불편한 점이 매우 많습니다. 이러한 문제점을 해소하기 위해 view engine을 사용합니다. 대표적인 view engine에는 pug, jinja2, ejs 등이 있으며, 준회원 스터디에서는 가독성이 좋고 간결한 pug를 사용합니다.

\subsection*{pug Syntaxes}

pug에 대해 간단하게 스터디하기 전에, 먼저 pug 모듈을 설치합니다.

\begin{shellenv}{shell:installing-pug}{Installing pug}\begin{verbatim}
$ npm install pug
\end{verbatim}
\end{shellenv}

이후 index.js를 \coderef{code:pug-example-index-js}\와 같이 작성합니다. \cd{app} 객체의 \cd{set} 메서드를 이용하여, 템플릿을 모아둔 폴더를 설정하고, view engine은 pug로 설정하였습니다. 이제 GET /, GET /page/:page, GET /posts/:until의 세 라우트를 구현하면서 pug 문법을 살펴봅시다.

\begin{codeenv}{code:pug-example-index-js}{pug Example Application - index.js}\begin{verbatim}
const express = require('express');

const port = 3000;
const app = express();

app.set('views', `${__dirname}/views`);
app.set('view engine', 'pug');

app.get('/', (req, res) => {});

app.get('/page/:page', (req, res) => {});

app.get('/posts/:until', (req, res) => {});

app.listen(port, () => console.log(`Server listening on port ${port}!`));
\end{verbatim}
\end{codeenv}

먼저 views/index.pug를 생성하고, \coderef{code:pug-example-index-pug}\와 같이 작성합니다.

\begin{codeenv}{code:pug-example-index-pug}{pug Example Application - views/index.pug}\begin{verbatim}
doctype html
html
    head
        title Index Page
        meta(charset='utf-8')
    body
        .page-header
            h1#page-title Index Title
            ul
                li
                    a(href='/board') Go to Board
                li
                    a(href='/article/compose') Compose New Article
        .page-body
            | Page Body
            | Hello World!
\end{verbatim}
\end{codeenv}

\coderef{code:pug-example-index-pug}의 템플릿에서 보듯, pug는 다음과 같은 특징을 갖습니다.

\begin{itemize}
    \item HTML 태그는 태그의 이름만 작성하고, 태그의 열고 닫음은 들여쓰기(indent)로 표현합니다.
    \item class와 id는 CSS를 작성하는 방식과 유사하게 작성합니다. class나 id가 있는 div 태그는 태그 이름을 생략할 수 있습니다.
    \item class, id를 제외한 태그 내의 속성(attribute)은 괄호 내에 attribute=value의 형태로 쓰며, 각 attribute 간에는 쉼표(,)로 구별합니다.
    \item 태그 내부의 내용이 한 줄이면 태그 부분 뒤에 한 칸을 띄고 내용을 작성합니다.
    \item 태그 내부의 내용이 여러 줄이면 다음 줄부터 줄마다 pipe(|)를 삽입한 뒤 한 칸을 띄고 내용을 작성합니다.
\end{itemize}

이렇게 작성된 템플릿은 응답 객체의 \cd{render} 메서드를 이용하여 HTML 문서로 변환(render)되어 응답으로 반환할 수 있습니다.

\begin{codeenv}{code:pug-example-get-index}{pug Example Application - index.js (GET /)}\begin{verbatim}
app.get('/', (req, res) => res.render('index.pug'));
\end{verbatim}
\end{codeenv}

\coderef{code:pug-example-index-js}에서 GET / 부분을 \coderef{code:pug-example-get-index}\와 같이 수정합니다. \cd{render} 함수에는 render하고자 하는 템플릿 파일의 상대 경로를 인자로 넘겨주면 됩니다. 단, 템플릿 파일의 상대 경로는 앞의 \coderef{code:pug-example-index-js}에서 선언한 템플릿 폴더가 기준입니다.

\begin{codeenv}{code:pug-example-board-pug}{pug Example Application - views/board.pug}\begin{verbatim}
doctype html
html
    head
        title Board Page
    body
        h1 Board Page
        h3 This is page #{page}
\end{verbatim}
\end{codeenv}

views/board.pug를 생성하고, \coderef{code:pug-example-board-pug}\와 같이 작성합니다. pug에서는 \cd{\#\{\}} 표현을 이용하여 템플릿에 JS 표현식의 값을 삽입합니다. 이는 \sectref{sect:advanced-javascript-syntaxes}에서 스터디한 template literal과 매우 유사합니다.

템플릿에서 사용되는 상수의 값들은 \cd{render} 메서드의 두 번째 인자로 객체의 형태로 넘겨주면, render 과정에서 해당 부분이 JS 표현식의 값으로 대체되어 render됩니다.

\begin{codeenv}{code:pug-example-get-board}{pug Example Application - index.js (GET /page/:page)}\begin{verbatim}
app.get('/page/:page', (req, res) => {
    res.render('board.pug', { page: req.params.page });
});
\end{verbatim}
\end{codeenv}

\coderef{code:pug-example-index-js}에서 GET /page/:page 부분을 \coderef{code:pug-example-get-board}\와 같이 수정합니다.

\begin{codeenv}{code:pug-example-posts-pug}{pug Example Application - views/posts.pug}\begin{verbatim}
doctype html
html
    head
        title Posts Page
    body
        if posts.length
            h1 Posts Count: #{posts.length}
            each post, index in posts
                h3 ##{index} - #{post}
        else
            h1 Invalid Page!
\end{verbatim}
\end{codeenv}

views/posts.pug를 \coderef{code:pug-example-posts-pug}\와 같이 작성합니다. 이처럼 템플릿 내에서 조건문과 반복문을 사용할 수 있습니다.

\begin{codeenv}{code:pug-example-get-posts}{pug Example Application - index.js (GET /posts/:until)}\begin{verbatim}
app.get('/posts/:until', (req, res) => {
    const { until } = req.params;
    const untilParsed = parseInt(until);

    const posts = [];
    if (!isNaN(untilParsed)) {
        for (let i = 0; i < untilParsed; i++) {
            posts.push(`Post ${i + 1}`);
        }
    }
    res.render('posts.pug', { posts });
});
\end{verbatim}
\end{codeenv}

\coderef{code:pug-example-index-js}에서 GET /page/:page 부분을 \coderef{code:pug-example-get-posts}\와 같이 수정하고, GET /posts/10 요청에 대한 응답과 GET /posts/tenth 요청에 대한 응답을 비교해봅니다.

pug의 자세한 문법은 공식 홈페이지(https://pugjs.org/api/getting-started.html)에서 확인할 수 있습니다.
