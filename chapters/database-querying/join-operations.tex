\section{Join Operations}\label{sect:join-operations}

\subsection*{Join Operation}

집합 $A=\{1,2,4\}$, $B=\{1,3,4\}$에 대해 두 집합의 곱집합 $A\times B$는 다음과 같이 정의된다.

$$ A\times B=\{(x,y)~|~x\in A,~y\in B\}=\{(1,1),(2,1),(4,1),(1,3),(2,3),(4,3),(1,4),(2,4),(4,4)\} $$

유사하게, join 연산은 두 개 이상의 테이블을 데카르트 곱(Cartesian Product), 즉 곱집합 하는 연산이다. \tblref{tab:join-example-tables}\와 같은 테이블 \cd{A}와 \cd{B}를 가정해보자.

\begin{table}[htb]
    \centering\caption{Table \cd{A} (left) and Table \cd{B} (right)\label{tab:join-example-tables}}\small
    \begin{subtable}[h]{.2\tw}\centering
        \begin{tabular}{?>{\colc}m{.2\tw}|>{\colc}m{.4\tw}?}
            \thickhline
            \rowcolor{tblheadcolor}
            \cd{id} & \cd{data}\tabularnewline
            \hline
            1 & A1\tabularnewline
            \hline
            2 & A2\tabularnewline
            \hline
            4 & A4\tabularnewline
            \thickhline
        \end{tabular}
    \end{subtable}
    \hspace{15pt}
    \begin{subtable}[h]{.2\tw}\centering
        \begin{tabular}{?>{\colc}m{.2\tw}|>{\colc}m{.4\tw}?}
            \thickhline
            \rowcolor{tblheadcolor}
            \cd{id} & \cd{data}\tabularnewline
            \hline
            1 & B1\tabularnewline
            \hline
            3 & B3\tabularnewline
            \hline
            4 & B4\tabularnewline
            \thickhline
        \end{tabular}
    \end{subtable}
\end{table}

이때, 두 테이블 \cd{A}와 \cd{B}를 join한 테이블은 \tblref{tab:join-example}\과 같다.

\begin{tblenv}
    {tab:join-example}
    {Table \cd{A} and \cd{B} Joined}
    {?>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}?}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data}\tabularnewline
    \hline
    1 & A1 & 1 & B1\tabularnewline
    \hline
    2 & A2 & 1 & B1\tabularnewline
    \hline
    4 & A4 & 1 & B1\tabularnewline
    \hline
    1 & A1 & 3 & B3\tabularnewline
    \hline
    2 & A2 & 3 & B3\tabularnewline
    \hline
    4 & A4 & 3 & B3\tabularnewline
    \hline
    1 & A1 & 4 & B4\tabularnewline
    \hline
    2 & A2 & 4 & B4\tabularnewline
    \hline
    4 & A4 & 4 & B4\tabularnewline
    \thickhline
\end{tblenv}

DB에서는 두 테이블을 단순히 join하여 사용하기보다는 특정 조건을 만족하는 row들만 join하여 사용하는 경우가 대부분이다.

\subsection*{Inner Join and Outer Join}

DB에서 두 테이블을 join할 때 T1 테이블에 T2 테이블을 join한다는 표현을 사용한다. 이때 편의상 T1 테이블을 왼쪽 테이블, T2 테이블을 오른쪽 테이블이라고 하자.

먼저 inner join은 양 테이블에서 join 조건을 만족하는 row들만 join하는 방식으로, \tblref{tab:inner-join-example}\은 \cd{A} 테이블에 \cd{B} 테이블을 \cd{A.id = B.id} 조건 하에 inner join한 결과이다. \cd{A} 테이블의 2번 row는 \cd{B} 테이블에 \cd{id}가 2인 row가 없어 join에 참여하지 못했고, \cd{B} 테이블에서도 3번 row가 같은 이유로 join에 참여하지 못했다. 이러한 inner join은 통상적으로 그냥 join이라고 불리며, 그 방식으로부터 \cd{A} 테이블에 \cd{B} 테이블을 inner join한 결과는 \cd{B} 테이블에 \cd{A} 테이블을 inner join한 결과와 같음을 알 수 있다.

\begin{tblenv}
    {tab:inner-join-example}
    {Table \cd{A} Inner Join Table \cd{B}}
    {?>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}?}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data}\tabularnewline
    \hline
    1 & A1 & 1 & B1\tabularnewline
    \hline
    4 & A4 & 4 & B4\tabularnewline
    \thickhline
\end{tblenv}

Outer join은 특정 테이블의 모든 row를 강제로 join에 참여시키고 대응되는 row가 없어 값이 정해지지 않는 column은 NULL로 채우는 join 방식이다. Outer join에는 left, right, full의 세 종류가 있다.

\begin{tblenv}
    {tab:left-outer-join-example}
    {Table \cd{A} Left Outer Join Table \cd{B}}
    {?>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}?}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data}\tabularnewline
    \hline
    1 & A1 & 1 & B1\tabularnewline
    \hline
    2 & A2 & NULL & NULL\tabularnewline
    \hline
    4 & A4 & 4 & B4\tabularnewline
    \thickhline
\end{tblenv}

먼저 left outer join은 왼쪽 테이블의 모든 row를 join에 강제로 참여시키는 방식으로, \tblref{tab:left-outer-join-example}\은 \cd{A} 테이블에 \cd{B} 테이블을 \cd{A.id = B.id} 조건 하에 left outer join한 결과이다. \cd{B} 테이블에 2번 row가 없음에도 불구하고 \cd{A} 테이블의 2번 row는 join에 참여하였고, \cd{B.id}와 \cd{B.data}의 값이 NULL임을 확인할 수 있다.

\begin{tblenv}
    {tab:right-outer-join-example}
    {Table \cd{A} Right Outer Join Table \cd{B}}
    {?>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}?}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data}\tabularnewline
    \hline
    1 & A1 & 1 & B1\tabularnewline
    \hline
    NULL & NULL & 3 & B3\tabularnewline
    \hline
    4 & A4 & 4 & B4\tabularnewline
    \thickhline
\end{tblenv}

Right outer join은 left outer join과 정반대로 오른쪽 테이블의 모든 row를 join에 강제로 참여시키는 방식으로, \tblref{tab:right-outer-join-example}\은 \cd{A} 테이블에 \cd{B} 테이블을 \cd{A.id = B.id} 조건 하에 right outer join한 결과이다. Outer join의 join 방식에서 알 수 있듯, \cd{A} 테이블에 \cd{B} 테이블을 left outer join한 결과는 \cd{B} 테이블에 \cd{A} 테이블을 right outer join한 결과와 동일하다. (반대도 성립)

\begin{tblenv}
    {tab:full-outer-join-example}
    {Table \cd{A} Full Outer Join Table \cd{B}}
    {?>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}?}
    \thickhline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data}\tabularnewline
    \hline
    1 & A1 & 1 & B1\tabularnewline
    \hline
    2 & A2 & NULL & NULL\tabularnewline
    \hline
    NULL & NULL & 3 & B3\tabularnewline
    \hline
    4 & A4 & 4 & B4\tabularnewline
    \thickhline
\end{tblenv}

Full outer join은 양쪽 테이블의 모든 row를 join에 강제로 참여시키는 방식으로, \tblref{tab:full-outer-join-example}\은 \cd{A} 테이블에 \cd{B} 테이블을 \cd{A.id = B.id} 조건 하에 full outer join한 결과이다. 이 방식은 inner join과 마찬가지로 교환법칙이 성립한다.

\figures{fig:join-venn-diagram}{Join Operations as Venn Diagrams}{
    \subfig{fig:inner-join}{Inner Join}
        {images/database-querying/inner-join.png}{.23}
    \subfig{fig:left-outer-join}{Left Outer Join}
        {images/database-querying/left-outer-join.png}{.23}
    \subfig{fig:right-outer-join}{Right Outer Join}
        {images/database-querying/right-outer-join.png}{.23}
    \subfig{fig:full-outer-join}{Full Outer Join}
        {images/database-querying/full-outer-join.png}{.23}
}

\figref{fig:join-venn-diagram}\은 네 개의 Join 연산을 벤 다이어그램 형태로 나타낸 것이다.

\subsection*{Join Operation in SQL}

Join 연산은 관계가 있는 테이블에서 데이터를 가져올 때 매우 유용하게 사용되어 관계형 DB의 꽃과 같은 연산이다. 따라서 SQL문을 이용하여 조건에 따라 join operation을 수행하는 방법을 예시 데이터와 함께 알아본다.

\begin{shellenv}{shell:import-sql-file}{Import SQL File}\begin{verbatim}
$ mysql –u<username> -p<password> -D<db-name> < <sql-file-path>
\end{verbatim}
\end{shellenv}

\shellref{shell:import-sql-file}\은 \cd{sql-file-path} 경로에 위치한 SQL 파일을 \cd{db-name} DB에 import하는 명령어이다. 이때 \cd{username} 계정은 \cd{db-name} DB에 권한을 갖고 있어야 한다.

\begin{codeenv}{code:join-example-sql}{SQL Join Example Data}\begin{verbatim}
CREATE TABLE `tb1` (`id` INT, `data1` VARCHAR(4), PRIMARY KEY (`id`)) ENGINE=InnoDB;
CREATE TABLE `tb2` (`id` INT, `data2` VARCHAR(4), PRIMARY KEY (`id`)) ENGINE=InnoDB;

INSERT INTO `tb1` VALUES (1,'1-1'),(6,'1-6'),(7,'1-7'),(8,'1-8'),(10,'1-10'),
(11,'1-11'),(12,'1-12'),(13,'1-13'),(14,'1-14'),(15,'1-15');
INSERT INTO `tb2` VALUES (2,'2-2'),(3,'2-3'),(4,'2-4'),(5,'2-5'),(7,'2-7'),(8,'2-8'),
(9,'2-9'),(11,'2-11'),(13,'2-13'),(14,'2-14');
\end{verbatim}
\end{codeenv}

\coderef{code:join-example-sql}\을 DB에 import한다. \cd{tb1} 테이블은 \cd{id}와 \cd{data1} column을, \cd{tb2} 테이블은 \cd{id}와 \cd{data2} column을 갖는다. \cd{INSERT} 키워드를 이용하여 각 테이블에 10개의 row를 삽입하였다.

\begin{sqlenv}{sql:join}{\cd{SELECT} with Join Operation Syntax}\begin{verbatim}
SELECT <columns> FROM <left-table>
    (INNER/LEFT OUTER/RIGHT OUTER) JOIN <right-table> ON <join-condition>
\end{verbatim}
\end{sqlenv}

\sqlref{sql:join}\은 \cd{left-table} 테이블에 \cd{right-table} 테이블을 \cd{join-condition}을 만족하며 join한 테이블을 생성하고, 그 테이블에서 \cd{SELECT} 키워드를 이용해 데이터를 조회하는 SQL문이다.

\begin{shellenv}{shell:sql-join-operations}{Join Operations Using SQL}\begin{verbatim}
> SELECT `data1` FROM `tb1`;
> SELECT `data2` FROM `tb2`;
> SELECT `tb1`.`data1`, `tb2`.`data2` FROM `tb1`
      INNER JOIN `tb2` ON `tb1`.`id` = `tb2`.`id`;
> SELECT `tb1`.`data1`, `tb2`.`data2` FROM `tb1`
      LEFT OUTER JOIN `tb2` ON `tb1`.`id` = `tb2`.`id`;
> SELECT `tb1`.`data1`, `tb2`.`data2` FROM `tb1`
      RIGHT OUTER JOIN `tb2` ON `tb1`.`id` = `tb2`.`id`;
\end{verbatim}
\end{shellenv}

\shellref{shell:sql-join-operations}\는 \cd{tb1} 테이블에 \cd{tb2} 테이블을 \cd{tb1.id = tb2.id} 조건 하에 join하는 예제\footnote{MariaDB(MySQL)에서 full outer join 연산은 각 테이블에서 데이터를 조회한 뒤 합집합을 생성하여야 한다. 그러나 full outer join은 자주 쓰이는 연산이 아니므로 본 교재에서는 생략한다.}이다. 각 join 방식에 따라 조회 결과가 어떻게 달라지는지 확인해본다.

Join 연산은 여러 테이블의 데이터를 동시에 다루기 때문에 서로 다른 테이블의 이름이 같은 column의 값을 조회하려고 하는 경우가 있다. \coderef{code:join-example-sql}의 예시에서도 \cd{tb1} 테이블의 \cd{id} column과 \cd{tb2} 테이블의 \cd{id} column은 서로 다른 column이지만 이름이 같다. 이때 \cd{id} column의 이름을 그냥 사용하면 SQL문 상에서 어느 테이블의 \cd{id} column인지 구분할 수 없다.

이러한 모호한(ambiguous) 상황을 피하기 위해 테이블 이름과 column 이름을 같이 작성하는 것이 권장되며, \cd{AS} 키워드를 사용하여 다른 이름으로 바꾸어 표시되도록 할 수 있다. \cd{AS} 키워드를 사용하여 SQL문이 너무 길어지는 것을 방지할 수도 있다.

\begin{shellenv}{shell:sql-as-keyword}{Column Alias Using \cd{AS} Keyword}\begin{verbatim}
> SELECT `tb1`.`id` AS `id1`, `data1`, `tb2`.`id` AS `id2`, `data2` FROM `tb1`
      INNER JOIN `tb2` ON `tb1`.`id` = `tb2`.`id`;
\end{verbatim}
\end{shellenv}

\shellref{shell:sql-as-keyword}\는 \cd{tb1.id} column의 이름을 \cd{id1}, \cd{tb2.id} column의 이름을 \cd{tb2}로 바뀌어 표시되도록 한 예제이다. 이때 원래 column 이름은 바뀌지 않는다.
