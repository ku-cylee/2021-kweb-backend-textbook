\section{Join Operations}\label{sect:join-operations}

\subsection*{Join Operation}

집합 $A=\{1,2,4\}$, $B=\{1,3,4\}$를 가정해봅시다. 이때, 두 집합의 곱집합 $A\times B$는 다음과 같이 정의됩니다.

$$ A\times B = \{(1,1),(2,1),(4,1),(1,3),(2,3),(4,3),(1,4),(2,4),(4,4)\} $$

유사하게, join 연산은 두 개 이상의 테이블을 데카르트 곱(Cartesian Product) 또는 곱집합 하는 연산입니다. \tblref{tab:join-example-tables}\와 같은 테이블 \cd{A}와 \cd{B}를 가정해봅시다.

\begin{table}[htb]
    \centering\caption{Table \cd{A} (left) and Table \cd{B} (right)\label{tab:join-example-tables}}\small
    \begin{subtable}[h]{.2\tw}\centering
        \begin{tabular}{|>{\colc}m{.2\tw}|>{\colc}m{.4\tw}|}
            \hline
            \rowcolor{tblheadcolor}
            \cd{id} & \cd{data} \tabularnewline
            \hline
            1 & A1 \tabularnewline
            \hline
            2 & A2 \tabularnewline
            \hline
            4 & A4 \tabularnewline
            \hline
        \end{tabular}
    \end{subtable}
    \hspace{15pt}
    \begin{subtable}[h]{.2\tw}\centering
        \begin{tabular}{|>{\colc}m{.2\tw}|>{\colc}m{.4\tw}|}
            \hline
            \rowcolor{tblheadcolor}
            \cd{id} & \cd{data} \tabularnewline
            \hline
            1 & B1 \tabularnewline
            \hline
            3 & B3 \tabularnewline
            \hline
            4 & B4 \tabularnewline
            \hline
        \end{tabular}
    \end{subtable}
\end{table}

이때, 두 테이블 \cd{A}와 \cd{B}를 join한 테이블은 \tblref{tab:join-example}\과 같습니다.

\begin{tblenv}
    {tab:join-example}
    {Table \cd{A} and \cd{B} Joined}
    {|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|}
    \hline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data} \tabularnewline
    \hline
    1 & A1 & 1 & B1 \tabularnewline
    \hline
    2 & A2 & 1 & B1 \tabularnewline
    \hline
    4 & A4 & 1 & B1 \tabularnewline
    \hline
    1 & A1 & 3 & B3 \tabularnewline
    \hline
    2 & A2 & 3 & B3 \tabularnewline
    \hline
    4 & A4 & 3 & B3 \tabularnewline
    \hline
    1 & A1 & 4 & B4 \tabularnewline
    \hline
    2 & A2 & 4 & B4 \tabularnewline
    \hline
    4 & A4 & 4 & B4 \tabularnewline
    \hline
\end{tblenv}

다만 DB에서는 두 테이블을 그냥 join하기보다는, 특정 조건을 만족하는 row들을 join하여 사용하는 경우가 많습니다.

\subsection*{Inner Join and Outer Join}

DB에서 두 테이블을 join할 때, T1 테이블과 T2 테이블을 join한다는 표현보다는 T1 테이블에 T2 테이블을 join한다는 표현을 사용합니다. T1 테이블에 T2 테이블을 join할 때, 편의상 T1 테이블을 왼쪽 테이블, T2 테이블을 오른쪽 테이블이라고 하겠습니다.

먼저 inner join은 양쪽 테이블에서 join 조건을 만족하는 row들만 join하는 방식입니다. \tblref{tab:inner-join-example}\은 테이블 \cd{A}에 테이블 \cd{B}를 \cd{A.id = B.id}를 만족하며 inner join한 결과입니다.

\begin{tblenv}
    {tab:inner-join-example}
    {Table \cd{A} Inner Join Table \cd{B}}
    {|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|}
    \hline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data} \tabularnewline
    \hline
    1 & A1 & 1 & B1 \tabularnewline
    \hline
    4 & A4 & 4 & B4 \tabularnewline
    \hline
\end{tblenv}

테이블 \cd{A}에서 join 조건을 만족하지 못한 2번 row는 join에 참여하지 못했고, 테이블 \cd{B}에서도 join 조건을 만족하지 못한 3번 row는 join에 참여하지 못한 것을 확인할 수 있습니다. 이와 같은 inner join은 통상적으로 그냥 join이라고 불리며, join 방식으로부터 테이블 \cd{A}에 테이블 \cd{B}를 inner join한 결과와 테이블 \cd{B}에 테이블 \cd{A}를 inner join한 결과는 동일함을 유추할 수 있습니다.

Outer join은 inner join과 join 방식이 약간 다릅니다. Outer join에는 left outer join과 right outer join이 있는데, 먼저 left outer join은 왼쪽 테이블의 모든 row를 join에 강제로 참여시키는 것입니다. Join 조건을 만족하는 row가 오른쪽 테이블에 있으면 해당 row와 join하고, 없으면 오른쪽 테이블에 해당하는 column을 \cd{NULL}로 채웁니다.

\tblref{tab:left-outer-join-example}\은 테이블 \cd{A}에 테이블 \cd{B}를 \cd{A.id = B.id}를 만족하며 left outer join한 결과입니다.

\begin{tblenv}
    {tab:left-outer-join-example}
    {Table \cd{A} Left Outer Join Table \cd{B}}
    {|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|}
    \hline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data} \tabularnewline
    \hline
    1 & A1 & 1 & B1 \tabularnewline
    \hline
    2 & A2 & NULL & NULL \tabularnewline
    \hline
    4 & A4 & 4 & B4 \tabularnewline
    \hline
\end{tblenv}

테이블 \cd{A}의 2번 row는 테이블 \cd{B}에 같은 \cd{id} 값을 갖는 row가 존재하지 않음에도 불구하고 join에 참여하였고, 대신 \cd{B.id}와 \cd{B.data}의 값이 \cd{NULL}인 것을 확인할 수 있습니다.

Right outer join은 left outer join의 정반대로, 오른쪽 테이블의 모든 row를 join에 강제로 참여시킵니다. \tblref{tab:right-outer-join-example}\은 테이블 \cd{A}에 테이블 \cd{B}를 \cd{A.id = B.id}를 만족하며 right outer join한 결과입니다.

\begin{tblenv}
    {tab:right-outer-join-example}
    {Table \cd{A} Right Outer Join Table \cd{B}}
    {|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|>{\colc}m{0.06\tw}|>{\colc}m{0.12\tw}|}
    \hline
    \rowcolor{tblheadcolor}
    \cd{A.id} & \cd{A.data} & \cd{B.id} & \cd{B.data} \tabularnewline
    \hline
    1 & A1 & 1 & B1 \tabularnewline
    \hline
    NULL & NULL & 3 & B3 \tabularnewline
    \hline
    4 & A4 & 4 & B4 \tabularnewline
    \hline
\end{tblenv}

Outer join의 join 방식에서 알 수 있듯, \cd{A} 테이블에 \cd{B} 테이블을 left outer join한 결과는 \cd{B} 테이블에 \cd{A} 테이블을 right outer join한 결과와 동일합니다. (반대도 성립)

\subsection*{Join Operation in SQL}

예제를 활용하여, inner join과 outer join을 이용하여 데이터를 조회하는 SQL문을 작성해보겠습니다. 5.7장의 Code 5.8의 코드를 02-join.sql에 저장하고, Shell 5.13과 같이 DB에 import한 뒤 \cd{DESC} 키워드를 이용하여 \cd{tb1} 테이블과 \cd{tb2} 테이블의 구조를 확인합니다.

\begin{sqlenv}{sql:join}{\cd{SELECT} with Join Operation Syntax}\begin{verbatim}
SELECT <columns> FROM <left-table>
(INNER/LEFT OUTER/RIGHT OUTER) JOIN <right-table> ON <join-condition>
\end{verbatim}
\end{sqlenv}

\sqlref{sql:join}\은 \cd{left-table} 테이블에 \cd{right-table} 테이블을 \cd{join-condition}을 만족하며 join한 테이블에서 데이터를 조회하는 SQL문입니다.

\begin{shellenv}{shell:sql-join-operations}{Join Operations Using SQL}\begin{verbatim}
> SELECT data1 FROM tb1;
> SELECT data2 FROM tb2;
> SELECT tb1.data1, tb2.data2 FROM tb1 INNER JOIN tb2 ON tb1.id = tb2.id;
> SELECT tb1.data1, tb2.data2 FROM tb1 LEFT OUTER JOIN tb2 ON tb1.id = tb2.id;
> SELECT tb1.data1, tb2.data2 FROM tb1 RIGHT OUTER JOIN tb2 ON tb1.id = tb2.id;
\end{verbatim}
\end{shellenv}

\shellref{shell:sql-join-operations}\는 \cd{tb1} 테이블에 \cd{tb2} 테이블을 \cd{db1.id = db2.id}를 만족하며 join하는 예제입니다. 각 join 방식에 따라, 조회 결과가 어떻게 달라지는지 확인해봅시다.

Join 연산은 여러 테이블의 데이터를 동시에 다루기 때문에, 조회 결과 column 이름이 같은 column이 존재하여, 모호함(ambiguous)을 유발할 수 있습니다. 모호함을 방지하기 위해 테이블 이름과 column 이름을 같이 작성하는 것이 권장되며, \cd{AS} 키워드를 이용하여 column 이름을 다른 이름으로 바뀌어 표시되게 함으로써 SQL문이 너무 길어지는 것을 방지할 수 있습니다. 반대로, column 이름이 겹치지 않는다면 테이블 이름을 생략할 수도 있습니다.

\begin{shellenv}{shell:sql-as-keyword}{Column Alias Using \cd{AS} Keyword}\begin{verbatim}
> SELECT tb1.id AS id1, data1, tb2.id AS id2, data2 FROM tb1
      INNER JOIN tb2 ON tb1.id = tb2.id;
\end{verbatim}
\end{shellenv}

이러한 join 연산은 여러 테이블의 데이터를 동시에 다룰 수 있도록 하여, 서로 관계가 있는 테이블들의 데이터를 간편하게 다룰 수 있도록 해줍니다.
