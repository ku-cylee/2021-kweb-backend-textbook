\section{Hash Functions and Encryption}\label{sect:hash-functions-and-encryption}

\subsection*{Encryption}

대부분의 웹 사이트는 사용자가 계정을 만든 뒤, 계정에 로그인하여 사용합니다. 이때 사용자는 아이디와 비밀번호 등의 정보를 서버에 제공하여 본인임을 인증합니다. 서버에서는 사용자의 아이디와 비밀번호 등을 DB에 저장해두고, 사용자로부터 인증 요청을 받으면 DB에 저장된 데이터와 비교하여 사용자 본인이 맞는지 검증합니다.

이러한 인증과 관련된 데이터를 DB에 저장할 때, 비밀번호와 같은 민감한 정보를 단순 텍스트(plain text)로 저장하면 DB가 해킹되었을 때 사용자의 암호는 고스란히 공격자의 손에 넘어가게 되기 때문에, 이러한 정보는 반드시 암호화(encryption)하여 저장하여야 합니다.

암호화 알고리즘은 크게 단방향 암호화와 양방향 암호화, 두 가지가 나뉩니다. 양방향 암호화 알고리즘은 더 세분화하여 비대칭형 암호화와 대칭형 암호화로 나누기도 합니다. 암호화된 메시지를 원래 메시지로 변환하는 과정을 복호화(decryption)라고 하는데, 양방향 암호화 알고리즘은 복호화가 가능한 알고리즘인 반면, 단방향 암호화 알고리즘은 복호화가 불가능한 알고리즘입니다. 웹 애플리케이션에서는 이러한 암호화 알고리즘을 사용하여 사용자의 비밀번호를 암호화한 후, 암호화된 비밀번호를 DB에 저장해야 합니다.

웹 애플리케이션에서의 사용자 인증 작업이 어떤 과정을 거쳐 수행되는지 생각해봅시다. (\figref{fig:user-auth-algorithm}) 사용자로부터 아이디와 비밀번호를 전달받으면, 먼저 DB에서 아이디 column의 값이 입력받은 아이디와 일치하는 record를 조회하여, 조회 결과가 없으면 가입되어 있지 않은 아이디로 판별합니다. 아이디가 존재하면, 입력받은 비밀번호와 해당 record의 비밀번호 값이 일치하는지 확인하여, 일치 여부에 따라 인증의 성공 여부를 판별합니다.

\figures{fig:user-auth-algorithm}{User Authentication Algorithm}{
    \fig{images/authentication/user-auth-algorithm.png}{.8}
}

이러한 알고리즘으로 인증을 수행할 때, 사용하는 암호화 알고리즘이 동일한 입력에 대해서 항상 동일한 결과를 도출하는, 즉 결정론적으로 작동하는 알고리즘이라면, 웹 애플리케이션은 암호화된 비밀번호를 이용하여 원래 비밀번호를 도출할 필요가 없습니다. 대신 사용자가 입력한 비밀번호를 같은 방법으로 암호화하여, DB에 저장된 암호화된 비밀번호와 동일한지 확인하면, 사용자가 입력한 비밀번호가 옳은 비밀번호인지 판별할 수 있습니다. 따라서, 비밀번호 등을 암호화하기 위해 대부분 결정론적으로 작동하는 단방향 함수인 해시 함수를 이용합니다.

\subsection*{Hash Function}

해시 함수(hash function)는 입력받은 데이터를 암호화하여 해시값으로 변환하는 함수로, 웹 애플리케이션에서의 비밀번호 암호화뿐만 아니라 데이터의 무결성을 검증하는 체크섬 등 널리 사용되는 함수입니다. 이러한 해시 함수는 다음과 같은 몇 가지 특징을 갖습니다.

먼저, 해시 함수는 결정론적 알고리즘으로, 동일한 두 입력값의 해시값은 반드시 같습니다. 이에 대한 대우 명제 역시 항상 참이므로 해시값이 다른 두 입력값은 반드시 다릅니다. 그러나, 두 입력값이 다른 값이더라도 해시값이 반드시 다르다는 보장은 없습니다. 이렇게 서로 다른 두 입력값에 대한 해시값이 같은 경우를 해시 충돌(hash collision)이라고 합니다.

해시 함수의 두 번째 특징은 입력값의 길이와 무관하게 해시값의 길이는 고정되어 있다는 것이며, 이 고정된 길이는 알고리즘마다 다릅니다. 입력값에는 길이 제한이 없는데, 해시값의 길이는 고정되어 있으므로 해시 충돌은 필연적으로 발생합니다. 그러나, 실제로는 비밀번호 등에 입력값에 길이 제한이 존재하고, 해시값이 길이는 충분히 기므로 해시 충돌이 발생할 확률은 극히 낮습니다.\footnote{키보드로 입력할 수 있는 문자는 95개이고, 비밀번호의 길이가 8-30자로 제한된다면 $\sum_{i=8}^{30}95^i\approx 2.17\times 10^{58}$가지; 해시값의 길이가 512비트인 SHA-512 알고리즘의 경우의 수는 $2^{512}=1.34\times 10^{154}$가지; 해시 충돌 발생 확률은 $1.62\times 10^{-96}$}

해시 함수의 세 번째 특징은 입력값에서 발생한 아주 작은 변화가 해시값에서 아주 큰 변화를 발생시킨다는 점입니다. 크기가 매우 큰 두 입력값의 데이터 중 단 1비트만 달라도, 전혀 다른 해시값이 생성됩니다. 이러한 특징을 눈사태 효과(avalanche effect)라고 하며, 이로 인해 해시값을 이용하여 입력값을 유추할 수 없고, 연산 속도가 매우 빠르다는 특징과 맞아떨어져 매우 큰 파일이 전송 과정에서 손상되었는지 확인하는 무결성 검증(체크섬)에서도 널리 사용됩니다.

통상적으로 사용되는 해시 함수에는 MD5, SHA-1, SHA-256, SHA-512, SHA-3 등이 존재합니다. 이 중 MD-5나 SHA-1 알고리즘은 출시된 지 오래되어 매우 취약하므로 보안 목적으로의 사용이 권장되지 않습니다. 현재는 주로 SHA-256과 SHA-512 등의 SHA-2 계열의 해시 함수가 널리 사용되고 있고, SHA-3 해시 함수의 사용이 권장되고 있습니다.

이번 장에서는 Node.js에서 해시 함수를 제공하는 모듈을 이용하여 SHA-512 해시 함수를 사용해보겠습니다.

\subsection*{Simple Encryption in Node.js}

Node.js의 내장 모듈인 crypto는 문자열을 암호화할 수 있는 해시 함수를 제공하는 모듈입니다.

\begin{codeenv}{code:simple-sha512-hashing}{Simple Example of SHA-512 Hashing}\begin{verbatim}
const util = require('util');
const crypto = require('crypto');

const pbkdf2 = util.promisify(crypto.pbkdf2);

const encrypt = async text => {
    const ALGO = 'sha512';
    const KEY_LEN = 64;
    const digest = await pbkdf2(text, '', 1, KEY_LEN, ALGO);
    console.log(`${text} | ${digest.toString('hex')}`);
};

(async () => {
    await encrypt('password123');
})();
\end{verbatim}
\end{codeenv}

\coderef{code:simple-sha512-hashing}의 \cd{encrypt} 함수는 \cd{crypto} 모듈의 \cd{pbkdf2} 함수를 이용하여, 인자로 받은 문자열을 SHA-512 알고리즘으로 암호화한 후 16진수(hex, 4b)로 변환하여 출력하는 함수입니다. 여기에서 \cd{KEY\_LEN}은, 해시값의 몇 바이트를 사용할 것인지에 관한 인자로, 이 코드에서는 64B(=512b)를 사용합니다. 위의 코드를 실행하면 password123이라는 텍스트가 128(=512 / 4)자의 문자열로 변환된 것을 확인할 수 있습니다. 또한, 코드를 여러 번 실행하여도 항상 같은 암호화 결과가 나타나, 결정론적으로 작동함을 확인할 수 있습니다.

\begin{codeenv}{code:avalanche-effect}{Avalanche Effect (Derived from \coderef{code:simple-sha512-hashing})}\begin{verbatim}
(async () => {
    await encrypt('samplepasswordsamplepasswordsamplepasswordsamplepasswordsample');
    await encrypt('samplepasswordsamplepasswordsanplepasswordsamplepasswordsample');
})();
\end{verbatim}
\end{codeenv}

\coderef{code:avalanche-effect}\는 \coderef{code:simple-sha512-hashing}에서 \cd{encrypt} 함수의 인자를 바꾼 것으로, 62자의 문자로 이루어진 두 문자열은 단 한 자만 다릅니다. 그러나 이 코드를 실행해보면, 두 문자열의 해시값의 차이가 매우 크다는 것을 확인할 수 있어, 눈사태 효과를 직접 확인할 수 있습니다. 이렇게 큰 데이터에서 작은 차이를 탐지하려고 할 때, 각 데이터의 해시값을 이용하여 비교하면 보다 편리하게 탐지할 수 있습니다. 이러한 특성으로 인해, 실제로 해시 함수는 크기가 큰 파일이 전송 과정에서 손상되었는지 확인하기 위해 사용되는 체크섬(checksum)을 계산하기 위해 널리 사용됩니다.

이처럼 해시 함수를 이용하면 비밀번호 등과 같은 민감한 정보를 암호화한 후 저장하여, 정보를 보호할 수 있습니다. 그러나 해시 함수는 단방향 암호화 알고리즘이기 때문에 해시값으로부터 입력값을 수학적으로 유추할 수는 없지만, 결정론적으로 동작한다는 특징 때문에 공격자가 가능한 모든 입력값에 대한 해시값의 테이블을 만들어 저장해둔다면, 이를 이용하여 해시값에 대한 입력값을 유추할 수 있습니다. 이처럼 무수히 많은 입력값에 대한 해시값을 저장한 테이블을 레인보우 테이블(rainbow table)이라고 합니다. 해시 함수는 연산 속도가 빠르므로, 입력값에 제한 조건이 있다면 레인보우 테이블을 작성하는 것은 생각보다 쉽습니다. 그러므로 레인보우 테이블의 사용을 어렵게 하는 두 가지 방법을 알아보겠습니다.

\subsection*{Salting}

레인보우 테이블의 사용을 어렵게 하는 첫 번째 방법은 salt를 이용하는 것입니다. 여기에서 salt란, 랜덤하게 생성된 충분히 긴 길이의 문자열이며, salting은 암호화하고자 하는 텍스트에 salt를 붙여(concatenate) 입력값으로 사용하는 것입니다. 이렇게 얻은 해시값을 salt 값과 함께 저장하면, 사용자가 입력한 비밀번호를 인증할 때 입력받은 비밀번호를 salting하여 도출한 해시값과 저장된 비밀번호의 해시값을 비교하여 인증 여부를 판단할 수 있습니다. 반면 공격자로서는 입력값의 경우의 수가 많아져, 레인보우 테이블을 이용한 입력값 유추가 힘듭니다. 이때 salt 값의 길이는 32B 이상으로 설정하는 것이 권장됩니다.

\begin{codeenv}{code:salting}{Salting Input Text (Derived from \coderef{code:simple-sha512-hashing})}\begin{verbatim}
const randomBytes = util.promisify(crypto.randomBytes);

const encrypt = async text => {
    const ALGO = 'sha512';
    const KEY_LEN = 64;
    const salt = await randomBytes(32);
    const digest = await pbkdf2(text, salt, 1, KEY_LEN, ALGO);
    console.log(`${text} | ${salt.toString('hex')} | ${digest.toString('hex')}`);
};
\end{verbatim}
\end{codeenv}

\coderef{code:salting}\은 \coderef{code:simple-sha512-hashing}\을 수정하여 salt 값을 생성한 후, 이를 이용하여 암호화를 수행한 코드입니다.

\subsection*{Iteration}

레인보우 테이블의 사용을 어렵게 하는 두 번째 방법은 암호화를 여러 번 수행하는 것입니다. 입력값에 대해 salting하여 해시값을 얻은 후, 이 해시값을 다시 salting한 뒤 암호화하여 해시값을 도출합니다. 이를 지정된 횟수만큼 반복하여 도출된 해시값을 저장합니다. 이러한 방법 역시 공격자로서 입력값을 유추하기 힘들게 합니다.

\begin{codeenv}{code:hashing-iteration}{Iteration of Hashing (Derived from \coderef{code:salting})}\begin{verbatim}
const encrypt = async text => {
    const ALGO = 'sha512';
    const KEY_LEN = 64;
    const salt = await randomBytes(32);
    const iter = parseInt(Math.random() * 20000) + 100000;
    const digest = await pbkdf2(text, salt, iter, KEY_LEN, ALGO);
    console.log(`${text} | ${iter} | ${digest.toString('hex')}`);
};
\end{verbatim}
\end{codeenv}

암호화 반복 횟수는 적어도 10만 회 이상, 랜덤하게 결정되는 것이 권장됩니다. \coderef{code:hashing-iteration}\은 \coderef{code:salting}\을 수정하여 암호화를 반복적으로 수행한 코드입니다. 이때 반복 횟수는 10만 이상, 12만 미만의 임의의 정수로 설정됩니다.

\subsection*{Storing and Verifying Password}

이제까지 비밀번호를 암호화하여 저장하는 방법에 대해 학습하였습니다. 암호화 과정에서 사용된 salt, 반복 횟수, 해시 알고리즘, 해시값의 길이 등의 인자(parameter)들은 해시값과 함께 저장되어야 합니다. \coderef{code:generating-password}\는 \coderef{code:hashing-iteration}\을 수정하여 암호화 인자들과 해시값을 콜론(\cd{:})을 구분자로 구분하여 문자열을 생성한 코드입니다. 이렇게 저장한 비밀번호는 콜론을 기준으로 저장된 비밀번호를 split하여 인자들과 해시값을 얻을 수 있습니다.

\begin{codeenv}{code:generating-password}{Generating Password (Derived from \coderef{code:hashing-iteration})}\begin{verbatim}
const generatePassword = async password => {
    const ALGO = 'sha512';
    const KEY_LEN = 64;
    const salt = await randomBytes(32);
    const iter = parseInt(Math.random() * 20000) + 100000;
    const digest = await pbkdf2(password, salt, iter, KEY_LEN, ALGO);
    return `${ALGO}:${salt.toString('hex')}:${iter}:${KEY_LEN}:${digest.toString('hex')}`;
};
\end{verbatim}
\end{codeenv}

이제 사용자로부터 입력된 비밀번호를 검증하는 코드를 작성해봅시다. 암호화된 비밀번호를 이용하여 암호화 과정에 사용된 인자들과 해시값을 도출할 수 있습니다. 그 후 암호화 인자들을 이용하여 입력받은 비밀번호를 암호화하고, 그 해시값을 저장된 해시값과 비교하여 검증할 수 있습니다.

\begin{codeenv}{code:password-verification}{Password Verification (Derived from \coderef{code:generating-password})}\begin{verbatim}
const verifyPassword = async (password, hashedPassword) => {
    const [algo, encodedSalt, iterStr, keyLenStr, encodedDigest] =
        hashedPassword.split(':');
    const salt = Buffer.from(encodedSalt, 'hex');
    const iter = parseInt(iterStr);
    const keyLen = parseInt(keyLenStr);
    const storedDigest = Buffer.from(encodedDigest, 'hex');
    const digest = await pbkdf2(password, salt, iter, keyLen, algo);
    return Buffer.compare(digest, storedDigest) === 0;
};

(async () => {
    const hashedPassword = await generatePassword('password');
    const result1 = await verifyPassword('password', hashedPassword);
    const result2 = await verifyPassword('passsword', hashedPassword);
    console.log(`hashed: ${hashedPassword}`);
    console.log(`password: ${result1} / passsword: ${result2}`);
})();
\end{verbatim}
\end{codeenv}

\coderef{code:password-verification}\은 \coderef{code:generating-password}의 \cd{generatePassword} 함수를 이용하여 생성된 문자열을 이용하여, 사용자가 입력한 문자열이 알맞은 비밀번호인지 검증하는 \cd{verifyPassword} 함수를 작성한 것입니다.
